{"pages":[{"title":"About","date":"2017-11-23T14:15:32.992Z","path":"about/index.html","text":"站点简介 你好~ 欢迎来到我的个人 Wiki 站点。 此站点由我个人维护。 此站点使用了 Hexo + Github Page 搭建，使用了 Wikitten 的主题。 后面我自己稍微修改了一下样式，看看我的。 这是此站点的代码仓库：Personal Wiki。 此站点的内容主要是我个人在编程领域的技能树、个人管理以及一些生活的小 tips。 絮絮叨叨 我一直认可一个公式：思维能力 = 知识积累量 + 逻辑能力。 知识的积累量往往决定了你思维的高度，逻辑能力决定了你思维的缜密性。我到了大学之后，很多高中、初中无法想清楚、搞明白的问题或者某些现象，在我看了书、文章等等之后恍然大悟。 很多书、文章或者是仅仅一个论坛的帖子，一个回复，一个评论都有可能振聋发聩。 基础科学对我的认知的影响也是深远的。基础科学的意义就在于帮助你建立更加合理和客观的探索问题、思考问题的方式。历史、当下都有很多例子证明了不使用合理、客观的方法去探索事物、看待事物会导致多么荒诞乃至严重的后果。 所以我一直对知识保持尊重和信仰。 所以我希望把他们记下来，有可能的话分享出去，并对他人有益。 联系我（Contact me）Blog：rosu’s Blog Telegram: @rosuh Email: cc # rosu.me(# -&gt; @) by rosu 2017-3-30 21:06:19"},{"title":"Tags","date":"2017-11-10T13:51:33.463Z","path":"tags/index.html","text":""},{"title":"Categories","date":"2017-11-23T14:15:32.463Z","path":"categories/index.html","text":""}],"posts":[{"title":"5 [BX] 和 loop 指令","date":"2017-12-26T08:23:07.162Z","path":"计算机技能/汇编基础/5-BX-and-loop-instruction/","text":"前言 1. [bx]和内存单元的描述 描述一个内存单元所需的两种信息 内存单元的地址 内存单元的长度（类型） [0] 表示一个内存单元时， 0 表示单元的偏移地址，段地址默认在 ds寄存器中，单元的长度（类型）可以由具体指令中的其他操作对象（比如寄存器）指出。 [bx] 是一个内存单元的地址 它的偏移地址存放在 bx中 1mov ax, [bx] 表示将一个内存单元的内容送入 ax，这个内存单元的长度位 2 字节（字单元），存放一个字节，偏移地址在 bx 中 ，段地址在 ds中 2. loop循环指令。 3. 我们定义的描述性符号：()为了描述上的简洁，在后续的学习中，我们将使用 () 来表示一个寄存器或一个内存单元中的内容： 12(ax) ; 表示 ax 中的内容(al) ; 表示 al 中的内容 4. 约定符号 idata表示常量12mov ax, [idata] ; 代表 mov ax,[1]、mov ax,[2]、或 mov ax,[3] 等mov bx, idata ; 代表 mov bx 1、mov bx, 2 或 mov bx, 3 等 5.1 [BX]2 个示例： 1mov ax, [bx] bx中存放的数据作为一个偏移地址 EA，段地址SA 默认在 ds 中，将 SA:EA 处的数据送入 ax 中。即：(ax) = ((ds)* 16 + (bx))。 1mov [bx], ax bx中存放的数据作为一个偏移地址 EA，段地址SA 默认在 ds 中，将 ax 中的数据送入内存 SA:EA 处。即：((ds)*16 + (bx) = ax) 5.2 Loop指令 loop指令的格式 1loop 标号 loop被执行的过程 (cx) = (cx) - 1 判断 cx 中的值，如果不为零则转至标号处执行程序，如果为零则向下执行 cx中存放循环次数 示例一 任务：编程计算 2^2，结果存放在ax 中 分析 设 (ax) = 2，可计算(ax) = (ax) * 2，最后(ax) 中为 2^2 的值 N*2 可用 N+N 实现 程序如下： 123456789assume cs:codecode segment mov ax, 2 add ax, ax mov ax, 4c00h int 21hcode endsend 示例二 任务：计算 2^3 分析： 2^3 = 2*2*2，若设 (ax) = 2，可计算(ax) = (ax) * 2 * 2，最后(ax) 中为 2^3 的值 N*2可用 N+N 实现 12345678910assume cs:codecode segment mov ax, 2 add ax, ax add ax, ax mov ax, 4c00h int 21hcode endsend 示例三 任务：编程计算2^12 分析 类似之前的例子 12345678assume cs:codecode segment mov ax, 2 ; 作 11 次 add ax, ax mov ax, 4c00h int 21hcode endsend 我们可以使用 loop 来简化我们的程序。 12345678910assume cs:codecode segment mov ax, 2 mov cx, 11s: add ax, ax loop s mov ax, 4c00h int 21hcode endsend 分析： 标号s 这个标号标识了一个地址，这个地址处有一条指令add ax, ax loop s CPU 执行 loop s 的时候，要进行两步操作 (cx) = (cx) - 1 判断 cx 中的值，不为 0 则转至标号 s 所标识的地址；如果为零则执行下一条 以下 3 条指令 123 mov cx, 11s: add ax, ax loop s 执行 loop s 时，首先要将 (cx) 减 1，然后若 (cx) 不为 0，则向前转至 s 处执行add ax, ax 利用 cx 可以用来控制 add ax,ax 的执行次数 5.3 在 Debug 中跟踪用 loop 指令实现的循环程序 问题 计算 ffff:0006 单元中的数乘以 3，结果存储在 dx 中。 考虑三个事项 运算后结果会否超出 dx 所能存储的范围？ ffff:0006单元中的数是一个字节型的数据，范围是 0~255 之间，则用它和 3 相乘结果不会大于 65535，可以在 dx 中存放下 用循环累加来实现乘法，用哪个寄存器进行累加 将 ffff:0006 单元中的赋值给 ax，用dx 进行累加。 先设(dx) = 0，然后作 3 次(dx) = (dx)+(ax) ffff:0006单元是一个字节单元，ax是一个 16 位寄存器，数据长度不一样，如何赋值？ 要想实现 ffff:0006 单元向 ax 赋值，应该令(ah) = 0, (al) = (ffff6h) 代码实现 12345678910111213141516171819assume cs:codecode segment mov ax, 0ffffh mov ds, ax mov bx, 6 ; 以上，设置 ds:bx 指向 ffff:6 mov al, [bx] mov ah, 0 ; 以上，设置(al)=((ds*16)+(bx)), (ah)=0 mov dx, 0 ; 累计寄存器清 0 mov cx, 3 ; 循环 3 次 s: add dx, ax loop s ; 以上累加计算(ax)*3 mov ax, 4c00h int 21h ; 返回code endsend 在汇编源程序中，数据不能以字母开头，所以要在前面加 0 对上面的程序编译、链接之后，使用 debug.exe 对程序执行过程进行观察。 u查看被 Debug 加载入内存的程序可以看到 loop s 语句 123456# 源代码语句s: add dx, ax loop s# 载入内存的语句0B3D:0012 ADD DX,AX0B3D:0014 LOOP, 0012 可以看到 s 已经被具体的地址所替代。 访问内存地址时，Debug的显示方式 10B44:0008 8A07 MOV AL,[BX] DS:0006=35 可以看到 debug 右边出现了内存地址 [bx] 中的内容。根据我们设置的，段地址 ds = ffff, bx=6，所以我们可知道ffff:6 内存单元中的值为35h。 接着就是 loop 指令的执行，注意 cx 寄存器中的值，当该值等于 0 时，就跳出循环。 现在我们知道，修改 cx 寄存器中的内容可以间接实现乘法算术，对于在 debug 中的跟踪技巧而言，我们可以使用 g 指令，来快速执行到某一指令。 1g 0012 这样就可以略过 ds:0012 之前的代码了。对于循环语句，就可以直接将地址改为循环后一句地址即可： 1g 0016 # 假设循环语句地址为 0014 此外，我们也可以使用 p 指令来自动执行循环。 遇到 int 21h 语句时应该使用 p 指令来正常结束程序哦。 5.4 Debug和汇编编译器 masm 对指令的不同处理 在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须用 [...] 来表示内存单元；如果在 [] 里用一个常量 idata 直接给出内存单元的偏移地址，就要在 [] 的前面显式地给出段地址所在的寄存器 12mov al, ds:[0] ; 如果没有给出 ds ，编译器 masm 就会把指令中的 [iadata] 解释为 idata 如果在 [] 里用寄存器，比如 bx，间接给出内存单元的偏移地址，则段地址默认在ds 中 也可以显式地给出段地址所在的段寄存器 5.5 loop和 [bx] 的联合应用 考虑这样一个问题，计算 ffff:0 ~ ffff:b 单元中的数据的和，结果存储在 dx 中。 一样的要考虑三个问题： 运算后结果是否会超出 dx 所能存储的范围？ ffff:0~ffff:b内存单元中的数据是字节型数据，范围在 0~255 之间，12 个这样的数据相加，结果不会大于 65535，可以在dx 中存放下。 我们能否将 ffff:0~ffff:b 中的数据直接累加到 dx 中？ 不行。ffff:0~ffff:b中的数据是 8 位的，不能直接加到 16 位寄存器 dx 中。 我们能否将 ffff:0~ffff:b 中的数据累加到 dl 中，并设置 (dh)=0，从而实现累加到dx 中？ 不行。dl是 8 位寄存器，能容纳的数据范围在 0~255，ffff:0~ffffLb 中的数据也是 8 位，如果仅向 dl 中累加 12 个 8 位数据，很有可能造成进位丢失的后果。 如何将 ffff:0~ffff:b 中的 8 位数据，累加到 16 位寄存器 dx 中呢？ 矛盾点在于： 类型不匹配 (dx)=(dx) + 内存中的 8 位数据：类型不匹配 结果的超界问题 (dl)=(dl) + 内存中的 8 位数据：结果可能超界 解决方法 用一个 16 位寄存器作为中介。将内存单元中的 8 位数据赋值到一个 16 位寄存器 ax 中，再将 ax 中的数据加到 dx 上，从而使得两个运算对象的类型匹配并且结果不会超界。 代码实现1234567891011121314151617181920212223assume cs:codecode segment mov ax, 0ffffh mov ds,ax mov dx, 0 mov al,ds:[0] mov ah,0 add dx,ax mov al,ds[1] mov ah,0 ... ; 直到 ds:[0bh] mov al, ds:[0bh] mov ah, 0 add dx, ax mov ax, 4c00h int 21hcode endsend 我们可以使用 loop 指令来优化代码： 1234567891011121314151617181920assume cs:codecode segment mov ax, 0ffffh mov ds, ax mov bx, 0 ; 初始化 ds:bx 指向 ffff:0 mov dx, 0 ; 初始化累加器 dx, (dx) = 0 mov cx, 12 ; 初始化循环技术寄存器 cx, (cx) = 12 s: mov al, [bx] mov ah, 0 add dx, ax ; 间接向 dx 中加上 ((ds) * 16 + (bx)) 单元中的值 inc bx ; ds:bx 指向下一个单元 loop s mov ax, 4c00h int 21hcode endsend 5.6 段前缀 mov ax, [bx]中，内存单元的偏移地址由 bx给出，而段地址默认在 ds 中 我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的寄存器 ​ 1mov ax, ds:[bx] 将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放在一个字，偏移地址在bx 中，段地址在 ds 中。 ​ 1mov ax, cs:[bx] 将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在bx 中，段地址在 cs 中。 ​ 1mov ax, ss:[bx] 将一个内存单元的内容送入 ax，这个内存单元长度为 2 字节（字单元），存放一个字，便宜地址在bx 中，段地址 ss 中。 ​ 1mov ax, es:[bx] 将一个内存单元的内容送入 ax，这个内存单元长度为 2 字节（字单元），存放一个字，便宜地址在bx 中，段地址 es 中。 ​ 1mov ax,ss:[0] 将一个内存单元的内容送入 ax，这个内存单元长度为 2 字节（字单元），存放一个字，便宜地址为 0 ，段地址ss 中。 ​ 1mov ax,cs:[0] 将一个内存单元的内容送入 ax，这个内存单元长度为 2 字节（字单元），存放一个字，便宜地址为 0 ，段地址cs 中。 上述文字中出现的ds:，cs:， ss:，es:，在汇编语言中称为段前缀。 5.7 一段安全的空间 在 8086 模式中，随意向一段内存地址空间写入内容是危险的，因为这段空间中可能存放着重要的系统数据或代码。即便是许多高级语言，也需要提前申请内容才能使用。 书中例子举出，在实模式（纯 DOS）模式下执行 mov [0026],ax 将会引起死机，因为地址 0:0026 存放着重要数据。 实际上，更多的情况我们都会在 CPU 实模式下进行编程。这样的硬件已被操作系统利用 CPU 保护模式所提供的功能全面而严格地管理着。 在后续的编程实践中，我们需要向内存直接写入内容，但是又不希望发生危险事故。所以我们需要找到一段安全的空间供我们使用。 在一般的 PC 机中，DOS 方式下，DOS 和其他合法的程序一般不会使用 0:200~0:2ff 的 256 个字节的空间 使用 deubg 查看 0:200~0:2ff 内存段如果都是 0 的话就表示没有人用过了。 5.8 段前缀的使用 考虑一个问题：将内存 ffff:0~ffff:b 单元中的数据复制到 0:200~0:20b 单元中。 分析： 0:200~0:20b单元等同于 0020:0~0020:b 单元，他们描述的是同一段内存空间 复制的过程应用循环实现 12345; 初始化x = 0; 循环 12 次; 将 ffff:x 单元中的数据送入 0020:x X = X + 1 在循环中，原始单元 ffff:x 和目标单元 0020:x 的偏移地址 X 是变量 我们使用 bx 来存放 将 0:200~0:20b 用0020:0~0020:b来描述，就是为了使目标单元的偏移地址和源始单元的偏移地址从同一数值 0 开始 程序如下： 12345678910111213141516171819assume cs:codecode segment mov bx, 0 ;(bx) = 0, 偏移地址从 0 开始 mov cx, 12 ;(cx) = 12, 循环 12 次s: mov ax, 0ffffh mov ds, ax ;(ds) = 0fffh mov dl, [bx] ;(dl) = ((ds) * 16 + (bx)), 将 ffff:bx 中的数据送入 dl mov ax,0020h mov ds,ax ;(ds) = 0020h mov [bx],dl ;((ds) * 16 + (bx)) = (dl), 将 dl 中数据送入 0020:bx inc bx ; (bx) = (bx) + 1 loop s mov ax, 4c00h int 21hcode endsend 解析： 源始单元 ffff:x 和目标单元 0020:x 相距大于 64KB ，在不同的 64KB 段里，程序需要设置两次ds 我们可以使用两个段寄存器分别存放源始单元 ffff:x 和目标单元 0020:x 的段地址 这样就可以省略需要重复 12 次的设置 ds程序段： 123456789101112131415161718192021assume cs:codecode segment mov ax, 0ffffh mov ds, ax mov ax, 0020h mov es, ax mov bx, 0 mov cx, 12 s: mov dl,[bx] mov es:[bx], dl inc bx loop s mov ax,4c00h int 21hcode endsend 实验四 [BX]和 loop 的使用 题目一 编程，向内存 0:200~0:23f 依次传送数据0~63(3FH) 123456789101112131415161718assume cs:codecode segment mov ax, 0 mov ds, ax mov bx, 0200h ; 使 ds:bx=0:200h mov cx, 64 ; 初始化循环计数器 mov dx, 0s: mov [bx], dx inc bx inc dx loop s mov ax,2c00h int 21hcode endsend 使用 ml 编译链接之后，使用 debug 调试即可。 题目二 编程，向内存 0:200~0:23f 依次传送数据 0~63(3FH)，程序只能使用 9 条指令，9 条指令中包括mov ax, 4c00h 和int 21h","tags":[{"name":"assembly","slug":"assembly","permalink":"https://wiki.rosuh.me/tags/assembly/"}],"categories":[{"name":"计算机技能","slug":"计算机技能","permalink":"https://wiki.rosuh.me/categories/计算机技能/"},{"name":"汇编基础","slug":"计算机技能/汇编基础","permalink":"https://wiki.rosuh.me/categories/计算机技能/汇编基础/"}]},{"title":"6 包含多个段的程序","date":"2017-12-26T08:23:07.162Z","path":"计算机技能/汇编基础/6-including-several-segment-program/","text":"前言 在操作系统环境中，合法地通过操作系统取得的空间都是合法的 在操作系统允许的情况下，程序可以取得任意容量的空间 程序取得所需空间的方法 加载程序时候为程序分配 在源码这种做出说明 通过定义段来获取内存空间 程序执行过程中向系统申请 在本课程中，我们只讨论第一种。 在一个段中存放数据、代码和栈，我们先来体会一下不使用多个段的情况 将数据、代码和栈放入不同的段中 6.1 在代码段中使用数据 编程计算下面 8 个数据的和，结果存储在 ax 寄存器中 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h 思路是将上述 8 个数据存放在一段连续的内存空间中然后使用循环累加最后将结果存放到 ax 中。 我们无法自己随意决定使用哪一段内存空间。所以我们需要在源码中向系统申请内存空间。 定义我们希望处理的数据 编译器编译这些数据、链接将之作为程序的一部分写入到可执行文件中 可执行文件被载入内存，这些 数据也同时被加载入内存中 1234567891011121314151617assume cs:codecode segment dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h mov bx, 0 mov ax, 0 mov cx, 8s: add ax,cs:[bx] add bx, 2 loop s mov ax, 4c00h int 21hcode endsend 解析： dw（define word）：定义字型数据 这里定义了 8 个字型数据，他们一共占据 16 字节的内存空间 字型数据的位置 代码段：因为他们在代码段中，所以他们的段地址可以通过 CS 寄存器获得 偏移量：因为他们处于代码段的最开始，所以偏移地址为 0 bx寄存器通过自加 2 来移动到下一个字型数据的位置 使用 dw 定义的数据，在内存中也被以二进制的形式存放进去。通过 debug 调试查看上述程序。 u指令： 可以看到，在 0b3d:0013 以前的代码几乎是“看不懂”的。因为这一段存储的是原始的二进制数据，所以 debug 无法解析出对应的汇编语句。 当我们使用 d 语句就可以看到该代码段存放的其实就是那 8 个字型数据了。 当然这个时候你就不能直接使用 t 指令来执行语句了。正如前面所说的，CS:IP指向了程序的开头，也就是存放 dw 定义的字型数据的地方，哪些地方根本不对应那些汇编语句。 我们需要手动将 IP 设置为 10h，从而使CS:IP 执行程序中的第一条指令。接着再用 t 或p或 g 命令执行。 这样的程序有显而易见的缺漏： 我们必须使用 debug 来启动程序 在系统中直接运行可能会出现问题，因为程序的入口并不是我们期望的指令 现在我们来解决程序入口问题： 1234567891011121314151617assume cs:codecode segment dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h start: mov bx, 0 mov ax, 0 mov cx, 8s: add ax,cs:[bx] add bx, 2 loop s mov ax, 4c00h int 21hcode endsend start 解析： 程序的入口指令面前加上start 伪指令 end 后面同样加上start end的作用 通知编译器程序结束 通知编译器程序的入口在什么地方 单任务系统中，可执行文件的程序执行过程如下 由其他程序 (Debug, command 或其他程序)将可执行文件中的程序加载入内存 设置 CS:IP 指向程序的第一条要执行的指令（程序的入口），从而使程序得以运行 根据可执行文件中的描述信息指明哪一条指令是第一条指令 源程序中的“描述信息”部分，合乎上面中的 end 相关语句；易言之，end start指明程序的入口，被转化为一个入口地址，存储在可执行文件的描述信息中 程序结束运行之后，返回到加载者 现在我们可以这样安排程序框架： 1234567891011assume cs:codecode segment ... data ...start: ... code ...code endsend start 6.2 在代码段中使用栈 完成下面程序，利用栈，将程序中定义的数据逆序存放 1234567&gt; assume cs:codeseg&gt; codeseg segment&gt; dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h&gt; ?&gt; codeseg ends&gt; end&gt; &gt; 思路： 程序运行时，定义数据存放在 cs:0~cs:F 单元中，共 8 个字单元 依次将这 8 个字单元中的数据入栈，然后再依次出栈到这 8 个字单元中，从而实现逆序存放 要解决的问题就是必须要有一段可以使用的栈空间。我们需要在程序中通过定义数据来取得一段空间，将之当做栈空间来使用。 123456789101112131415161718192021222324252627282930assume cs:codesegcodeseg segment dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ; 用 dw 定义 16 个字型数据，在程序加载后，将取得的 16 个字 ; 内存空间，存放这 16 个数据 ; 在后面的程序中将这段空间当做栈来使用start: mov ax, cs mov ss, ax mov sp, 30h ; 设置栈顶 ss:sp 指向 cs:30 mov bx, 0 mov cx, 8 s: push cx:[bx] ; 将 0~15 单元中的 8 个字型数据依次入栈 add bx, 2 loop s mov bx, 0 mov cx, 8 s0: pop cs:[bx] ; 依次出栈 add bx, 2 loop s0 mov ax, 4c00h int 21hcodeseg endsend start 使用 dw 的真正目的是“开辟”存储空间，所以不管用什么值去申请都是可以的。申请之后我们在代码中将他作为栈来使用。 检测点 6.1 下面的程序实现依次用内存 0:0~0:15 单元中的内容改写程序中的数据，完成程序： 12345678910111213141516171819assume cs:codesegcodeseg segment dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h start: mov ax, 0 mov ds, ax mov bx, 0 mov cx, 8s: mov ax, [bx] _________ add bx, 2 loop s mov ax, 4c00h int 21hcodeseg endsend start 填入的答案应该是mov cs:[bx], ax。 cs:ip指向的是下一条指令的位置 cs存储着代码代码段，而 [bx] 表示偏移量，也正是代表着这个程序在内存空间中最开始的那一段 下面的程序实现依次用内存 0:0~0:15 单元中的内容改写程序中的数据，数据的传送用栈来进行。栈空间设置在程序内。完成程序： 123456789101112131415161718192021222324assume cs:codesegcodeseg segment dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0start: mov ax, ____ mov ss, ax mov sp, ____ mov ax, 0 mov ds, ax mov bx, 0 mov cx, 8s: push [bx] _________ add bx, 2 loop s mov ax, 4c00h int 21hcodeseg endsend start 思路： 继续我们上一个例子的想法，本程序源码存放在 cs 代码段，在内存中，排在前面的是两段我们申请空间，大小分别为 16 个字节和 20 个字节 前者是数据段，后者用来做栈 栈内空闲时，指针指向栈底部，所以sp = 36 = 16+20 –&gt; sp = 0024h 要用 0:0~0:15 的数据将我们定义的数据段内的数据重写 步骤是： 将 0:0~0:15空间数据依次入栈，后出栈到在 cs 段的数据 故而完整程序为： 123456789101112131415161718192021222324assume cs:codesegcodeseg segment dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0start: mov ax, cs ; 指向程序存放的代码段，以便找到数据段和栈段 mov ss, ax mov sp, 24h ; 设置栈底 mov ax, 0 mov ds, ax ; 指向要修改的目标内存地址 mov bx, 0 mov cx, 8s: push [bx] ; 将 0:0~0:15 数据依次入栈 pop cs:[bx] ; 将栈内数据弹出到我们定义的数据段内 add bx, 2 loop s mov ax, 4c00h int 21hcodeseg endsend start 参见 检测点 6.1","tags":[{"name":"assembly","slug":"assembly","permalink":"https://wiki.rosuh.me/tags/assembly/"}],"categories":[{"name":"计算机技能","slug":"计算机技能","permalink":"https://wiki.rosuh.me/categories/计算机技能/"},{"name":"汇编基础","slug":"计算机技能/汇编基础","permalink":"https://wiki.rosuh.me/categories/计算机技能/汇编基础/"}]},{"title":"9 使用布局和组件创建用户界面","date":"2017-12-22T08:40:05.242Z","path":"Android-开发/9-Using-layouts-and-Widgets-to-create-UI/","text":"9.1 使用图形布局工具 除了手动输入 XML 的方式创建，我们还可以使用图形布局工具来创建布局。 图形布局工具界面： 中间区域是界面预览窗口 右边是蓝图视图，可以看出各组件视图的轮廓、大小和比例 左边是组件面板 左下是组件树 右边是属性界面 9.2 引入ConstraintLayout ConstraintLayout工具可以为布局添加一系列约束 组件位置关系因为约束而发生变化 在 ConstraintLayout 里布置视图，只需要添加约束就可以 组件的大小调整方式有三 组件自己决定（wrap_content 手动调整 让组件充满约束布局 引入步骤 切换到 design 布局 右击要转换的布局 选中 convert ... to ConstraintLayout 即可 现在 Android Studio 会自动添加依赖，所以不需要手动家加入。 约束编辑器 在布局预览窗口顶部的工具栏上，有一些约束选项： 显示所有约束 自动连接切换开关 启动后，在预览界面拖移视图时，约束会自动配置 Android Studio 会猜测你的布局配置意图，然后自动连接 清除全部约束 猜测约束 类似自动连接 Android Studio 会自动帮你创建约束 我们先手动清除根视图的所有约束，然后一步一步添加回来。 腾出空间 选中某个组件，右边就可以编辑该组件的属性了。 组件的水平和竖直方向的尺寸是分别由宽度设置和高度设置决定的 能设置的值有以下三种： 设置类型 设置值 用法 固定大小 Xdp 以 dp 为单元，为视图指定固定值 包裹内容 wrap_content 设置视图想要的尺寸（随内容走），大到足够容纳内容 动态适应 0dp 允许视图缩放以满足指定约束 至于添加约束的方式，其实就是拉动组件轮廓四周的四个圆圈，然后吸附到另一个组件轮廓上。 约束的 XML 格式 刚刚添加了一个 ImgaeVIew 组件，并为之三个边添加了约束，使之呆在布局的右边。 我们来看看刚刚添加的组件的约束 XML 代码： 1234567891011&lt;ImageView android:id=\"@+id/imageView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"8dp\" android:layout_marginEnd=\"8dp\" android:layout_marginTop=\"8dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:srcCompat=\"@drawable/ic_solved\"/&gt; 可以看到约束相关的属性皆是 app:layout_constraint 开头的： 123app:layout_constraintBottom_toBottomOf=\"parent\"app:layout_constraintEnd_toEndOf=\"parent\"app:layout_constraintTop_toTopOf=\"parent\" 属性以 layout_ 开头皆属于布局参数（layout parameter） 组件的布局参数是用来向其父组件做指示用的：用来告诉父布局如何安排自己 想想之前那个layout_margin，还有layout_height，都是布局参数。 约束的名字是 constraintTop，这表示它是ImageView 的顶部约束 属性以 toTopof=&quot;parent&quot; 结束，表示约束是连接到父组件的 编辑属性","tags":[{"name":"Android","slug":"Android","permalink":"https://wiki.rosuh.me/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://wiki.rosuh.me/tags/RecyclerView/"}],"categories":[{"name":"Android 开发","slug":"Android-开发","permalink":"https://wiki.rosuh.me/categories/Android-开发/"}]},{"title":"8 使用 RecyclerView 显示列表","date":"2017-12-20T10:24:21.846Z","path":"Android-开发/8-using-recyclerview-to-display-list/","text":"前言 为了实现我们的本次的项目，也就是 CriminalIntent 应用中显示 crime 列表的功能，我们需要用 RecyclerView 来实现列表显示。 应用模型层将新增一个 CrimeLab 对象，该对象是一个数据集中存储池，用来存储 Crime 对象 显示 crime 列表需要在应用控制器层新增一个 activity 和一个fragment CrimeListActivity和CrimeListFragment 8.1 升级 CriminalIntent 应用的模型 我们需要将应用的模型层，从容纳单个 Crime 对象变为可容纳一组 Crime 对象。 单例与数据集中存储 Crime数组对象将存储在一个单例里 单例是特殊的 Java 类，在创建实例时，一个单例类仅允许创建一个实例 应用能在内存中存活多久，单例就存活多久 单例 要创建单例，需要创建一个带有私有构造方法及 get() 方法的类 如果实例已经存在，get()方法就直接返回它 如果实例不存在，get()方法就会调用构造方法创建它 CrimeLab.java 12345678910111213public class CrimeLab &#123; private static CrimeLab sCrimeLab; public static CrimeLab get(Context context) &#123; if (sCrimeLab == null) &#123; sCrimeLab = new CrimeLab(context); &#125; return sCrimeLab; &#125; private CrimeLab(Context context)&#123; &#125;&#125; sCrimeLab变量带有 s 前缀，这是 Android 开发的命名约定，一看到此前缀，我们就直到 sCrimeLab 是一个静态变量 CrimeLab的构造方法是私有的，其他类无法创建 CrimeLab 对象，只能通过 get() 方法 get()方法中，我们传入 Context 对象 接着，我们往 CrimeLab 中存储 Crime 对象： 在 CrimeLab 的构造方法里，创建一个空 List 用来保存 Crime 对象 getCrime()用来返回数组列表 getCrime(UUID)返回带指定 ID 的Crime对象 创建可容纳 Crime 对象的List（CrimeLab.java） 1234567891011121314151617181920public class CrimeLab &#123; ... private List&lt;Crime&gt; mCrimes; ... private CrimeLab(Context context) &#123; mCrimes = new ArrayList&lt;&gt;(); &#125; public List&lt;Crime&gt; getCrimes() &#123; return mCrimes; &#125; public Crime getCrime(UUID id) &#123; for (Crime crime: mCrimes) &#123; if (crime.getID().equals(id)) &#123; return crime; &#125; &#125; return null; &#125;&#125; 解析： List&lt;E&gt;是一个泛型类，支持存放特定数据类型的有序列对象，拥有获取、新增和删除列表元素的方法 mCrimes含有 ArrayList：鉴于此，推荐在声明变量的时候使用List 接口类型；这样在有需要的时候还可以使用其他List mCrimes实例化语句使用的 &lt;&gt; 是在 Java 7 中引入的 该符号告诉编译器，List中的元素类型可以基于变量声明传入的抽象参数来确定 变量声明语句 private List&lt;Crime&gt; mCrimes 中指定了 Crime 参数，所以编译器可据此推测出 ArrayList 里可放入 Crime 对象 下面先批量存入 100 个 Crime 对象。 123456789private CrimeLab(Context context)&#123; mCrimes = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++)&#123; Crime crime = new Crime(); crime.setTitle(\"Crime #\" + i); crime.setSolved(i % 2 == 0); //Every other one mCrimes.add(crime); &#125; &#125; 8.2 使用抽象 activity 托管 fragment 记得我们需要为 fragment 创建一个 activity 视图来容纳它吗？ 创建托管 CrimeListFragment 的CrimeListActivity类之前，首先为 CrimeListActivity 创建视图。 通用型 fragment 托管布局 通用的布局定义文件 activity_fragment.xml 容器视图： 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/fragment_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; 此处没有特别指定 fragment，任何使用activity 托管 fragment 的场景，都可以使用它 抽象 activity 类可以复用 CrimeActivity 的代码来创建 CrimeListActivity 类。 近乎通用的 CrimeActivity 类(CrimeActivity.java)： 12345678910111213141516171819public class CrimeActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_fragment); FragmentManager fm = getSupportFragmentManager(); Fragment fragment = fm.findFragmentById(R.id.fragment_container); if (fragment == null) &#123; fragment = new CrimeFragment(); fm.beginTransaction() .add(R.id.fragment_container, fragment) .commit(); &#125; &#125;&#125; 可以看到这样的代码结构比较简单，而每一次新建一个 activity 都需要创建这样一段代码。所以我们可以将重复的代码封装为抽象类。（后文的 CrimeActivit 和CrimeListActivity都会用到此类代码，所以有复用价值） 创建一个 SingleFragmentActivity 的抽象类。设置超类为 AppCompatActivity 类。 创建一个 Activity抽象类（SingleFragmentActivity.java）： 12345678910111213141516171819public abstract class SingleFragmentActivity extends AppCompatActivity &#123; protected abstract Fragment createFragment(); @Override protected void onCreate(Bundle saveInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_fragment); FragmentManager fm = getSupportFragmentManager(); Fragment fragment = fm.findFragmentById(R.id.fragment_container); if (fragment == null) &#123; //* fragment = createFragment(); fm.beginTransaction() .add(R.id.fragment_container, fragment) .commit(); &#125; &#125;&#125; 可以看到上述方法除了在 * 号处将 new Fragment() 改为 createFragment() 抽象类方法外，其余和 CrimeActivity.java 中没什么区别。 我们要做的工作就是让 SingleFragmentActivity 的子类实现该方法，来返回 activity 托管的 fragment 实例。 使用抽象类 改动一下 CrimeActivity 类，将它的超类改为 SingleFragmentActivity。然后删除onCreate(Bundle) 方法，再添加createFragment。 清理 CrimeActivity 类(CrimeActivity.java)： 123456public class CrimeActivity extends SingleFragmentActivity &#123; @Override protected Fragment createFragment() &#123; return new CrimeFragment(); &#125;&#125; 新建控制类 类似的，使用 SingleFragmentActivity 类来创建控制类。 实现CrimeListActivity(CrimeListActivity.java) 123456public class CrimeListActivity extends SingleFragmentActivity() &#123; @Override protected Fragment createFragment() &#123; return new CrimeListFragment(); &#125;&#125; 当然我们还要实现CrimeListActivity.java，这样才能使用构造器创建。不过现在我们对这个控制类先留空： CrimeListFragment.java： 123public class CrimeListFragment extends Fragment&#123; // Nothing yet&#125; 在配置文件中声明CrimeListActivity 创建完CrimeListActivity，记得要在配置文件中声明它 因为本程式启动时的主界面应该是 crime 列表，因此还要在 AndroidManifest.xml 中声明为launch activity 123456&lt;activity android:name=\".CrimeListActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 8.3 RecyclerView, ViewHolder和Adapter RecyclerView是 ViewGroup 的子类 每一个列表只显示 Crime 的标题和日期 View是一个包含两个 TextView 的LinearLayout 仔细看看图片里的 RecyclerView 和View的关系。 当前屏幕只显示了 12 个子View。不在视线中的子View，就不会被创建出来。 你滑动屏幕就会显示更多子项目，然后之前出现过的，而不在视线中的子 View 就会被回收。 RecyclerView所做的事情，就是创建视线中的子项以及回收再利用，循环往复 RecyclerView的任务仅限于回收和定位屏幕上的View ViewHolder ViewHolder只做一件事：容纳 View 视图 下面是 典型的 ViewHolder 子类： 123456789public class ListRow extends RecyclerView.ViewHolder &#123; public ImageView mThumbnail; public ListRow(View view) &#123; super(view); mThumbnail = (ImageView) view.findViewById(R.id.thumbnail); &#125;&#125; 我们可以创建 ListRow 来获取自定义的 mThumbnail 和RecyclerView.ViewHolder超类传入的itemView。 ViewHolder为 itemView 而生：它引用着传给 super(view) 的整个视图 ViewHolder的使用示例： 123ListRow row = new ListRow(inflater.inflate(R.layout.list_row, parent, false));View view = row.itemView;ImageView thumbnailView = row.mThumbnail; RecyclerView本身不会创建视图，它创建的是 ViewHolder，而ViewHolder 引用着itemView Adapter RecyclerView自己不创建ViewHolder 这个任务交给了Adapter Adapter是一个控制器对象，从模型层获取数据，然后提供给 RecyclerView 显示，是沟通的桥梁 Adapter负责 创建必要的ViewHolder 绑定 ViewHolder 至模型层数据 要创建 Adapter，首先要定义RecyclerView.Adapter 子类 然后由它封装从 CrimeLab 获取的crime RecyclerView需要显示视图对象时，就会找他的Adapter RecyclerView-Adapter对话 首先，调用 Adapter 的getItemCount()方法，RecyclerView询问数组列表中包含多少个对象 接着，RecyclerView调用 Adapter 的onCreateViewHolder(ViewGroup, int)方法创建 ViewHolder 及其要显示的视图 最后，RecyclerView会传入 ViewHolder 及其位置，调用onBindViewHolder(ViewHolder, int) Adapter会找到目标位置的数据并将其绑定到 ViewHolder 视图上 绑定：使用模型数据填充视图 onCreateViewHolder(ViewGroup, int)方法调用并不频繁 一旦有了够用的 ViewHolder，RecyclerView 就会停止调用 ViewHolder(...) 方法 它会回收 ViewHolder 以节约时间和内存 使用RecyclerView 添加依赖 你可以在 build.gradle 文件中直接写入 RecyclerView 的依赖库。不过我觉得更好的方法是在 Project Structure–&gt;app–&gt;Dependencies 添加依赖。这样会直接搜索最新版的依赖项。 修改 .xml 文件，将根视图改为RecyclerView，并配置 ID 属性 在布局文件中添加 RecyclerView 视图（fragment_crime_list.mxl） 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v7.widget.RecyclerView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/crime_recycler_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; 关联视图和fragment 修改 CrimeListFragment.java 类文件，使用布局并找到布局中的 RecyclerView 视图。 为 CrimeListFRagment 配置视图（CrimeListFragment.java） 1234567891011121314public class CrimeListFragment extends Fragment &#123; private RecyclerView mCrimeRecyclerView; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_crime_list, container, false); mCrimeRecyclerView = (RecyclerView)view .findViewById(R.id.crime_recycler_view); mCrimeRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity())); return view; &#125;&#125; RecyclerView视图创建完成之后，立即转交给了 LayoutManager 对象 LayoutManager对象负责在屏幕上摆放列表项还负责定义屏幕滚动行为，因此没有了它，RecyclerView没法正常工作，应用可能会崩溃 目前实现了一个 RecyclerView 空视图。要显示出 crime 列表项，还需要完成 Adapter 和ViewHolder的实现。 列表项视图 我们要为 RecyclerView 上的列表项创建视图层级结构。 list_item_crime.xml： 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:padding=\"8dp\"&gt; &lt;TextView android:id=\"@+id/crime_title\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Crime Title\"/&gt; &lt;TextView android:id=\"@+id/crime_date\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Crmie Date\"/&gt;&lt;/LinearLayout&gt; 实现 ViewHolder 和Adapter接着我们在 CrimeListFragment 类中定义 ViewHolder 内部类，它会实例化并使用 list_item_crime 布局。 定义 ViewHolder 内部类（CrimeListFragment.java）： 123456789public class CrimeListFragment extends Fragment &#123; ... private class CrimeHolder extends RecyclerView.ViewHolder&#123; public CrimeHolder(LayoutInflater inflater, ViewGroup parent) &#123; super(inflater.inflate(R.layout.list_item_crime, parent,false)); &#125; &#125;&#125; 在 CrimeHolder 的构造方法里，我们首先实例化 list_item_crime 布局，然后传给 super(...) 方法，也就是 ViewHolder 构造方法 基类 ViewHolder 因而实际上引用这个视图 我们可以在 itemView 变量中找到它 接下来实现Adapter。 创建 Adapter 内部类（CrimeListFragment.java） 12345678910public class CrimeListFragment extends Fragment &#123; ... private class CrimeAdapter extends RecyclerView.Adapter&lt;CrimeHolder&gt; &#123; private List&lt;Crime&gt; mCrimes; public CrimeAdapter(List&lt;Crime&gt; crimes) &#123; mCrimes = crimes; &#125; &#125;&#125; 需要显示新创建的 ViewHolder 或让 Crime 对象和已创建的 ViewHolder 关联时，RecyclerView会去找Adapter（调用它的方法） RecyclerView不关心也不了解具体的 Crime 对象，这是 Adapter 要做的事 我们还需要在 Crimedapter 中实现三个方法： 武装CrimeAdapter（CrimeListFragment.java） 12345678910111213141516171819...private class CrimeAdapter extends RecyclerView.Adapter&lt;CrimeHolder&gt;&#123; ... @Override public CrimeHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; return null; &#125; @Override public void onBindViewHolder(CrimeHolder holder, int position) &#123; &#125; @Override public int getItemCount() &#123; return 0; &#125; &#125; RecyclerView需要新的 ViewHolder 来显示列表时，会调用 onCreateViewHolder 方法 这个方法内部，我们创建一个LayoutInflater，然后用它创建CrimeHolder 关联 Adapter 和RecyclerView 实现一个设置 CrimeListFragment 用户界面的 updateUI 方法 该方法创建CrimeAdapter，然后设置给RecyclerView 设置Adapter（CrimeListFragment.java） 1234567891011121314151617181920212223242526public class CrimeListAdapter extends Fragment &#123; ... private CrimeAdapter mAdapter; @Override public View onCreateView(LayourInflater inflater, ViewGroup container, Bundler savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_crime_list, container, false); mCrimeRecyclerView = (RecyclerView) view .findViewById(R.id.crime_recycler_view); mCrimeRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity())); updateUI(); // ** return view; &#125; public void updateUI() &#123; CrimeLab crimeLab = CrimeLab.get(getActivity()); List&lt;Crime&gt; Crimes = crimeLab.getCrimes(); mAdaper = new CrimeAdapter(crimes); mCrimeRecyclerView.setAdapter(mAdapter); &#125;&#125; 现在已经实现了基本的列表内容了。可以编译运行看看啦。 8.4 绑定列表项 绑定：让 Java 代码（Crime里的模型数据，或点击监听器）和组件关联起来 因为 CrimeHolder 会循环使用，分开处理视图创建和绑定会有好处 我们把视图绑定工作放入 CrimeHolder 类里 绑定之前，首先实例化相关组件；此项工作是一次性任务，因此直接放在构造方法里处理 在构造方法中实例化视图组件（CrimeListFragment.java） 1234567891011private class CrimeHolder extends RecyclerView.ViewHolder &#123; private TextView mTitleTextView; private TextView mDateTextView; public CrimeHolder(LayoutInflater inflater, ViewGroup parent) &#123; super(inflater.inflate(R.layout.list_item_crime, parent,false)); mTitleTextView = (TextView)itemView.findViewById(R.id.crime_title); mDateTextView = (TextView)itemView.findViewById(R.id.crime_date); &#125;&#125; CrimeHolder还需要实现一个 bind(Crime) 方法 每次有新的 Crime 要在 CrimeHolder 中显示时，都要调用它一次 实现 bind(Crime) 方法（CrimeListFragment.java） 12345public void bind(Crime crime) &#123; mCrime = crime; mTitleTextView.setText(mCrime.getTitle()); mDateTextView.setText(mCrime.getDate().toString()); &#125; 现在只要取得一个 Crime，CrimeHolder 就会刷新显示 TextView 标题视图和 TextView 日期视图 最后修改 CrimeAdapter 类，使用 bind(Crime) 方法：每次 RecyclerView 要求 CrimeHolder 绑定对应的 Crime 时，都会调用 bind(Crime) 方法。 调用bind(Crime)（CrimeListFragment.java） 123456789private class CrimeAdapter extends RecyclerView.Adapter&lt;CrimeHolder&gt; &#123; ... @Override public void onBindViewHolder(CrimeHolder holder, int position) &#123; Crime crime = mCrimes.get(position); holder.bind(crime); &#125; ...&#125; 8.5 响应点击 一般来说，RecyclerView只处理列表项相关工作，而触摸事件是需要我们自己实现的。 实现触摸事件常用方案就是设置 OnClickListener 监听器。既然列表项视图都关联着 ViewHolder，就可以让ViewHolder 为它监听用户触摸事件。 检测用户点击事件（CrimeListFragment.java） 12345678910111213private class CrimeHolder extends RecyclerView.ViewHolder implements View.OnClickListener&#123;... itemView.setOnClickListener(this); &#125; @Override public void onClick(View view) &#123; Toast.makeText(getActivity(), mCrime.getTitle() + \"clicked!\", Toast.LENGTH_SHORT) .show(); &#125; &#125;","tags":[{"name":"Android","slug":"Android","permalink":"https://wiki.rosuh.me/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://wiki.rosuh.me/tags/RecyclerView/"}],"categories":[{"name":"Android 开发","slug":"Android-开发","permalink":"https://wiki.rosuh.me/categories/Android-开发/"}]},{"title":"7 UI Fragmnet 与 fragment 管理器","date":"2017-12-14T07:44:09.355Z","path":"Android-开发/7-UI-Fragment-and-fragmen-manager/","text":"7.1 UI 设计的灵活性需求 复杂的用户界面呈现需求 平板以及大尺寸手机显示问题 滑动屏幕等交互问题 acticity 视图局限性 我们需要 activity 界面可以在运行时组装甚至时重新组装，但是其本身并不具备这样的灵活性 activity 还得和特定的用户界面紧紧绑定 7.2 引入 fragment fragment 是一种控制器对象 activity 可以委托它执行任务 这些任务通常是管理用户界面 受管的用户界面可以时一整屏或时整屏的一部分 采用 fragmnet 来管理 UI，可以绕开 android 系统 activity 使用规划的限制 管理用户界面的 fragment 又称为 UI fragment 它自己也有产生于布局文件的视图 fragment 视图包含了用户可以交互的可视化 UI 元素 activity 视图能预留位置供 fragment 视图插入 多个 fragment 则需要预留多个位置以供插入 activity 视图和 fragment 的关系和切换如下 fragment 可以带来灵活多变的布局，代价就是复杂的应用、更多的组件以及大量实现的代码 7.3 着手开发示例应用CriminalIntent 就是本示例应用的名称咯。 我们先来梳理一下开发流程。 我们先来看一下整个 CriminalIntent 项目的对象图解，以便我们更好地理解开发流程 解析： CrimeFragment的作用与 activity 在GeoQuiz应用中的作用差不多，都是负责创建并管理用户界面，以及与模型对象进行交互 Crime实例代表某种办公室陋习 crime有一个标题、一个标志 ID，一个日期和一个布尔值 布尔值用来表示陋习是否被解决 简单起见，本章使用一个 Crime 实例，并将其存放在 CrimeFragment 类的成员变量 mCrime 中 CrimeActivity视图（其对应的 .xml 文件）由 FragmentLayout 组件组成，FragmentLayout组件为 CrimeFragment 视图安排了显示位置 CrimeFragment视图由一个 LineaLayout 组件及其三个子视图组成；CrimeFragment类中由存储它们的成员变量，并设有监听器，会响应用户操作，更新模型数据 EditText Button CheckBox CrimeFragment 首先设计一个名为 CrimeFragment 的 UI fragment 来管理用户界面 再设计一个名为 CrimeActivity 的 activity 来托管 CrimeFragment 实例 activity 在其视图层内提供一处位置，用来放置 fragment 视图 fragment视图本身没有在屏幕上显示视图的能力；只有将它放置在 activiti 视图层级结构中，fragment视图才能显示在屏幕上 两类 fragment 原生版本的fragment 内置于设备系统中，如果应用要支持各个系统版本，在不同设备上运行的 fragment 可能会有不同的表现（因为各个版本的维护有差异） 支持库里的fragment 发布时，内置于应用中；使用支持库的 fragment 在不同设备上都会由相同的表现 我们使用的支持库版本来自 AppCompat 库 一般选用支持库中的 fragment 实现，因为考虑到 fragment API 不断引入新特性以及支持库不断更新的现状。 在 Android Studio 中增加依赖关系 要使用 AppCompat 库，项目必须加入依赖关系： 打开应用模块的 build.gradle 文件 app/build.gradle 1234dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'com.android.support:appcompat-v7:26.1.0'&#125; Android Studio 在 build.gradle中将原来的 compile改为了 api和implementation。 参看：Why Android change ‘compile’ task to ‘implementation’ task in gradle build? 接着我们先创建模型层的 Crime 类。 创建 Crime 类123456789101112public class Crime &#123; private UUID mId; private String mTitle; private Date mDate; private boolean mSolved; public Crime()&#123; mId = UUID.randomUUID(); mDate = new Date(); &#125;&#125;// 略去 getter() 和 setter() 方法 解析： UUID类是 Android 框架里的 Java 工具类 在构造方法里，调用 UUID.randomUUID() 会产生一个随机唯一 ID 值 使用默认的 Date 构造方法初始化 DAte 变量 作为 crime 的默认发生时间，设置 mDate 变量值为当前日期 7.4 托管 UI fragment 为了托管 UI fragment，activity 必须： 在其布局中为 fragment 的视图安排位置 管理 fragment 实例的生命周期 fragment的生命周期 下图展示了 fragment 的生命周期： fragment的生命周期类似于 activity 的生命周期，它具有停止、暂停以及运行状态，也拥有覆盖方法，用来在一些关键节点完成一些任务 fragment生命周期和 activity 的方法的对应关系 因为 fragment 代表 activity 工作，所以它的状态应该反映 activity 的状态 fragment生命周期与 activity 生命周期的一个关键不同在于： fragment的生命周期方法由托管 activity 而不是操作系统调用的 操作系统不关心 activity 用来管理视图的 fragment；易言之，fragment 的使用是 activity 内部的事情 托管的两种方式 activity 托管 UI fragment 有如下两种方式： 在 activity 布局中添加fragment 使用布局fragment 简单但不灵活：在 activity 布局中添加 fragment，就等同于将fragment 及其视图与 activity 的视图绑定在一起，并且在 activity 的生命周期过程中，无法替换 fragment 视图 在 activity 代码中添加fragment 比较复杂，但是也是唯一可以动态控制 fragment 的方式 何时添加 fragment 以及随后可以完成何种具体任务由你自己决定；也可以移除、替换和重新添加当前 fragment 等等 为了追求真正灵活的 UI 设计，就必须通过代码的方式添加fragment。 接下来我们将定义 CrimeActivity 的布局。 定义容器布局 尽管我们选择的是在 activity 代码中添加 UI fragment，但是我们依旧 要在 activity 视图层级结构中为 fragment 视图安排位置。 在 CrimeActivity 的布局中，该位置就是下图所示的FrameLayout： FragmentLayout是服务于 CrimeFragment 的容器视图 此容器视图是个通用性视图，不单用于 CrimeFragment 类，你还可以用它托管其他的fragment 我们会在 activity_crime.xml 文件中使用 FragmentLayout 作为默认布局： 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"https://schemas.android.com/apk/res/android\" android:id=\"@+id/fragment_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; 当前的 activity_crime.xml 布局文件仅由一个服务于单个 fragment 的容器视图组成 除了自身组件之外，托管 activity 布局还可定义多个容器视图 7.5 创建 UI fragment 创建 UI fragment 的步骤与创建 activity 的步骤相同： 定义用户界面布局文件 创建 fragment 类并设置其视图为定义的布局 编写代码以实例化组件 定义 CrimeFragment 的布局 CrimeFragment视图用来显示包含在 Crime 类实例中的信息 balabala… 创建 CrimeFragment 类 实现 fragment 生命周期方法 CrimeFragment类是与模型及视图对象交互的控制器，用于显示特定的 cirme 的明确信息。并在用户修改这些信息立即进行更新。 我们上一个例子中，activity通过其生命周期方法完成了大部分逻辑控制工作。在本个例子中，这些工作 fragment 的生命周期方法完成的。 CrimeFragment.java 12345678910import android.support.v4.app.Fragment;public class CrimeFragment extends Fragment &#123; private Crime mCrime; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mCrime = new Crime(); &#125;&#125; 解析： Fragment.onCreate(Bundle)是公共方法，而 Activity.onCreate(Bundle) 是受保护方法 Fragment.onCreate(Bundle)方法及其他 Fragment 生命周期方法必须是公共方法，因为托管 fragment 的activity要调用它们 Fragment同样具有保存及获取状态的bundle 类似于使用 Activity.onSaveInstanceState(Bundle)，我们需要覆盖Fragment.onSaveInstanceState(Bundle) 来使用 fragment的视图不是在 Fragment.onCreate(Bundle) 中生成的，虽然我们在该方法中配置了 fragment 实例，但是创建和配置 fragment 视图是在另一个 fragment 生命周期方法完成的 12public View onCrateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;&#125; 该方法实例化 fragment 视图的布局，然后将实例化的 View 返回给托管的activity LayoutInflater, ViewGroup是必要参数，Bundle用来存储恢复数据，可供该方法从保存状态下重建视图 下面我们在 CrimeFragment.java 中，添加 onCreateView 方法的实现代码，从 fragment_crime.xml 布局中实例化返回布局。 123456@Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle saveInstanceState) &#123; View v = inflater.inflate(R.layout.fragment_crime, container, false); return v; &#125; 解析： 在 onCreateView(...) 方法中，fragment的视图是直接通过调用 LayoutInflater.inflate(...) 方法并传入布局的资源 ID 生成的 第二个参数是视图的父视图，我们通常需要父视图来正确配置组件 第三个参数告诉布局生成器是否将生成的视图添加个给父视图 传入 flase 表示我们将以代码的方式添加视图 在 fragment 中实例化组件 fragment中的 EditText, CheckBox, Button 组件，也都是在 onCreateView(...) 方法里实例化的。 12345678910111213141516171819202122232425@Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle saveInstanceState) &#123; View v = inflater.inflate(R.layout.fragment_crime, container, false); mTitleFiled = (EditText)v.findViewById(R.id.crime_title); mTitleFiled.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; // This space intentionally left blank &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; mCrime.setTitle(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; // This on too &#125; &#125;); return v; &#125; 对比 Activity 中实例化组件，Fragment中需要手动调用 View.findViewById() 方法 onTextChanged(..)方法中，调用 CharSequence(表示用户输入) 的toString()方法 该方法最后返回用来设置的 Crime 标题字符串 接下来设置 Button 组件，让他显示 crime 的发生日期。 12345... mDateButton = (Button)v.findViewById(R.id.crime_date); mDateButton.setText(mCrime.getDate().toString()); mDateButton.setEnabled(false);... 此处只是显示日期，而点击功能没有启用。 接着设置 ChcekBox 组件。引用它并设置监听器，根据用户操作，更新 mSolved 状态。 123456789... mSolvedCheckBox = (CheckBox)v.findViewById(R.id.crime_solved); mSolvedCheckBox.setOnCheckedChangeListener(new OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; mCrime.setSolved(isChecked); &#125; &#125;);... 7.6 向 FragmentManager 添加 UI fragmentfragment 自己无法在屏幕上显示视图，我们需要把 CrimeFragment 添加给CrimeActivity。 FragmentManager类负责管理 fragment 并将它们的视图添加到 activity 的视图层级结构中 Activity类中添加了FragmentManager FragmentManager具体管理 fragment队列 fragment事务回退栈 在本例中，我们只需关心 FragmentManager 管理的 fragment 队列。 以代码的方式将 fragment 添加给 activity，需要直接调用activity 的fragmentManager 先获取 fragmentManager 本身 在 CrimeActivity.java 中，在 onCreate(Bundle) 方法中添加代码取得fragmentManager 获取fragmentManager（CrimeActivity.java） 12345678910public class CrimeActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_crime); android.support.v4.app.FragmentManager fm = getSupportFragmentManager(); &#125;&#125; fragment事务 获取 fragmentManager 后，再获取一个 fragment 交给它管理。 添加一个CrimeFragment（CrimeActivity.java） 1234567Fragment fragment = fm.findFragmentById(R.id.fragment_container);if (fragment == null) &#123; fragment = new CrimeFragment(); fm.beginTransaction() .add(R.id.fragment_container, fragment) .commit();&#125; new –&gt; add –&gt; commit 事务的创建到提交的过程 fragment事务用来被添加、移除、附加、分离或替换 fragment 队列中的fragment 这是 fragment 动态组装和重新组装用户界面的关键 Fragment.beginTransaction() 创建并返回 fragmentTransaction 实例 该实例类支持流接口（fluent interface）的链式方法调用，以此配置 FragmentTransaction 再返回它 add是整个事务的核心 参数 容器视图资源 ID 告诉 FragmentManager，fragment 视图应该出现在 activity 视图的什么位置 作为 FragmentManager 队列中 fragment 的唯一标志 新创建的CrimeFragment 从 FragmentManager 中获取CrimeFragment，使用容器视图资源 ID 就行了 如果要向 activity 添加多个 fragment，通常就需要分别为每个fragment 创建具有不同 ID 的不同容器 总结起来，其是就是： FragmentManafer和 fragment 生命周期 activity的 FragmentManager 负责调用队列中的 fragment 的生命周期方法 添加 fragment 供FragmentManager管理时，onAttach(Context), onCreate(Bundle)和 onCreateView(...) 方法会被调用 托管 activity 的onCreate(Bundle)方法执行后，onActivityCreated(Bundle)方法也不会被调用 因为 CrimeActivity.onCreate(Bundle) 方法中添加 CrimeFragment，所以fragment 被添加后，该方法会被调用 当 activity 处于运行状态时，添加 fragment 后 FragmentManager会立即驱赶（指让 fragment 走得快一点…）fragment，调用一系列必要的生命周期方法，快速赶上 activity 的步伐 一旦赶上，托管的 activity 的FragmentManager就会边接收操作系统的指令，边调用其他生命周期方法，让 fragment 与activity的状态保持一致 7.7. 采用 fragment 应用架构 尽管 fragment 组件可以复用，但是正确使用 fragment 非常重要 ，否则就边成了滥用。 fragment时用来封装关键组件以便复用 关键组件：针对应用的整个屏幕来讲的 单屏使用大量的 fragment，不仅使代码充斥fragment 事务处理，模块的职责分工也会不清晰 如果由很多零碎的晓组件需要复用，比较好的架构设计时使用定制视图 实践证明：应用单屏最多使用 2 ~ 3 个 fragment 使用 fragment 的理由 实际开发中，尽管有时候可用可不用，但是我们还是会采用fragment 因为后期添加 fragment 是一个大坑 作者坚信的 AUF（Always Use Fragments），总是使用fragment。 7.8 深入学习：fragment与支持库 AppCompat库没有实现 fragment 功能，它依赖于 support-4 库，是个后者实现了 fragment 功能 support-v4实现了 fragment 功能 其库内也有一个 Activity 子类：FragmentActivity 而 AppCompatActivity 时FragmentActivity的子类，所以应用能使用支持库版本的fragment 7.9 深入学习：为什么优先使用支持库版本的 fragment 支持库版本的 fragment 使用起来最方便 Google 每年会多次更新支持库，并借此引入新特性、修复 bug 支持库的本意是方便在不支持该 API 的旧版本上使用 支持库版本的 fragment 没有显著的缺点 功能实现上和系统内置的没有不同 唯一缺点是导入支持库包会占用额外空间 如何使用内置版？如果要使用内置版本的fragment，需要对项目作如下改动： 弃用 FragmentActivity 类，改用标准库中的 Activity 类（android.app.Activity） 弃用 android.support.v4.app.Fragment 类，改用 android.app.Fragment 类 弃用 getSupportFragmentManager() 方法，改用 getFragmentManager() 方法获取FragmentManager","tags":[{"name":"Android","slug":"Android","permalink":"https://wiki.rosuh.me/tags/Android/"},{"name":"frgament","slug":"frgament","permalink":"https://wiki.rosuh.me/tags/frgament/"}],"categories":[{"name":"Android 开发","slug":"Android-开发","permalink":"https://wiki.rosuh.me/categories/Android-开发/"}]},{"title":"4 第一个程序","date":"2017-12-07T05:02:55.535Z","path":"计算机技能/汇编基础/4-the-first-program/","text":"4.1 一个源程序从写出到执行的过程 编写汇编源程序 产生一个存储源程序的文本文件 对源程序进行编译链接 使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件进行链接。生成可在操作系统中直接运行的可执行文件 可执行文件包含两部分内容 程序和数据 程序：从源程序中的汇编指令翻译过来的机器码 数据：源程序中定义的数据 相关的描述信息 描述类似程序多大、占用多少内存空间等等 执行可执行文件中的程序 操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如设置 CS:IP 指向第一条要执行的指令），容纳后由 CPU 执行程序 4.2 源程序 下面时一段简单的汇编程序： 1234567891011assume cs:codesgcodesg segment mov ax, 0123H mov bx, 0456H add ax, bx add ax, ax mov ax, 4c00H int 21Hcodesg endsend 程序说明 伪指令 在汇编程序中有两种指令： 汇编指令 对应机器码，被编译为机器指令，最终被 CPU 执行 伪指令 编译器执行伪指令。编译器将根据伪指令来进行相关的编译工作 在上面的例子中的伪指令：12345XXX segment : : :XXX ends segment和 ends 是成对使用的伪指令 这是在写可被编译器编译的汇编程序时必须要用到的一对伪指令 segmnet和 ends 的功能是定义一个段 segment说明一个段的开始 ends说明一个段的结束 使用格式 123段名 segment :段名 ends 一个汇编程序由多个段组成，这些段被用来存放代码、数据或当作栈空间来使用 end 汇编程序的结束标记 如果程序写完了，就要在结尾处加上指令end，否则编译器无法知道程序在何处结束 assume 这条伪指令的含义为“假设”。他假设某一段寄存器和程序中的某一个 segment...ends 定义的段相关联，通过 assume 说明这种关联 在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系 在例子中，code segment...codeseg ends定义了一个名为 codeseg 的段，在这个段中存放代码，所以这个段是一个代码段。在程序的开头，用 assume cs:codeseg 将用作代码段的段 codeseg 和 CPU 中的段寄存器 cs 联系起来。 源程序中的“程序”用汇编语言写的源程序，包括伪指令和汇编指令： 汇编指令组成了最终由计算机执行的程序 源程序中的伪指令由编译器执行 源程序汇总最终由计算机执行、处理的程序或数据，称为程序 。 程序最先以汇编指令的形式存在于源程序中，经过编译、链接后转变为机器码，存储在可执行文件中。 标号 源程序中除了汇编指令和伪指令外，还有一些标号，比如codeseg 一个标号指代了一个地址 codeseg在 segment 的前面，作为一个段的名称，这个段最终将被编译、链接程序处理为一个段的段地址 程序的结构 定义一个程序段 123abc segment :abc ends ​ 在段中写入指令，实现任务 12345abc segment mov ax, 2 add ax, ax add ax, axabc ends ​ 指出程序在何时结束 1234567abc segment mov ax, 2 add ax, ax add ax, axabc endsend ​ 将程序段和寄存器联系起来 1234567assume cs:abcabc segment mov ax, 2 add ax, ax add ax, axabc endsend 程序返回 当一个程序结束后，将 CPU 的控制权交还给是他得以运行的程序，这个过程就叫程序返回 在程序的末尾添加返回的程序段以实现程序返回 12mov ax, 4c00Hint 21H 语法错误和逻辑错误4.3 编辑源程序 可以使用 Edit 的方式编辑源程序 也可以使用其他类型文本编辑器，然后保存后缀为 asm 文件 4.4 编译 source.asm–&gt;target.obj 源文件编译之后产生目标文件 中途可以选择生成 列表文件，这个文件是编译器将源程序编译为目标文件的过程中产生的中间结果 中途还可以加入 交叉引用文件 编译环境 编译的环境，从 windows 的 masm和 ml 到 Linux 的fasm，不一而足。不同的环境对编译伪指令的支持不一样，需要查阅文档。 4.5 链接 target.obj –&gt; Linked –&gt; execute.exe 将目标文件链接之后产生可执行文件 链接环境 windows 下的link.exe 和ml.exe 链接的作用是什么？ 如果源程序很大，可以将它分为多个源程序来编译，每个源程序编译成目标文件后，再用链接程序将它们链接到一起，生成一个可执行文件 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件链接到一起，生成一个可执行文件 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容不能直接用来生成可执行文件，链接程序将这些内容处理为最终的可执行信息 4.6 谁来执行可执行文件？ CPU 控制权 在 DOS 中，可执行文件中的程序 P1 若要运行，必须由一个正在运行的程序 P2，将P1 从可执行文件中载入内存，将 CPU 的控制权交给它；当 P1 运行完毕后，P1将 CPU 控制权交还P2 在上述程序中，将 1.exe 载入内存的，就是shell。 操作系统的 Shell 任何通用的操作系统，都要提供一个 shell （外壳）程序，供操作人员使用这个程序来操作计算机 DOS 的 shell DOS 中有一个command.com，这个被称为命令解释器的东西就是 DOS 系统的 shell 了 DOS 启动完成初始化之后，就会运行command.com command.com运行后，执行完其他任务之后，在屏幕上显示出当前盘符和路径组成的提示符，等待用户输入 4.9 程序执行过程的跟踪 为了查看程序运行过程的细节，以便跟踪错误，我们可以使用 debug 来查看单步执行的过程 1debug 1.exe 进入 debug 环境后，就可以使用 debug 的指令来控制程序的运行了。 r CX寄存器表示当前程序的长度 程序被藏在了哪里？ debug会先找一个单元作为起止地址为SA:0000（即起止地址的偏移地址为 0）的容量足够的空闲内存区 在这段内存区的前 256 个字节中，创建一个称为程序段前缀（PSP）的数据区，DOS 要利用 PSP 来和被加载的程序进行通信 从这段内存区的 256 字节处开始（在 PSP 的后面），将程序装入，程序的地址被设为SA+10H:0 将该段内存区的段地址存入 ds 中，初始化其他相关寄存器后，设置 CS:IP 指向程序的入口 int 21 执行之后，程序显示出 Program terminated normally 返回到 debug 中，则表示程序正常结束了 要使用 P 命令执行int 21","tags":[{"name":"assembly","slug":"assembly","permalink":"https://wiki.rosuh.me/tags/assembly/"}],"categories":[{"name":"计算机技能","slug":"计算机技能","permalink":"https://wiki.rosuh.me/categories/计算机技能/"},{"name":"汇编基础","slug":"计算机技能/汇编基础","permalink":"https://wiki.rosuh.me/categories/计算机技能/汇编基础/"}]},{"title":"4 积极的环境能改变人","date":"2017-11-23T14:15:32.663Z","path":"软技能/积极心理学/4.0-positive-environment-can-change-person/","text":"改变 传播真正有用的东西 传播真实的知识 研究 “精英民主化” 学习优秀的，让全体都变得优秀 “阻止改变的障碍” 低估了自己带来变化的能力 “改变如何发生”？ 改变可以呈几何级数扩散 &lt;–&gt; 理解人群中的指数效应 &lt;–&gt; 扩大影响力 “蝴蝶效应” “六度分离现象” “微笑效应” “凭外因无法令人幸福” 剧烈的外界环境变化对幸福感的影响只持续一段时间，之后将会回到原来的水平 一旦满足基本需求之后，幸福感将不会再有很大提升 并不是说毫无变化，只是外界某一因素 剧烈变化，易会导致其他因素协同变化，人生会出现新的体验，会让你开心亦会让你伤心，所以幸福值又回到了原来水平 社会制度影响除外，民主制度下的人们比独裁统治下的人们更幸福（可能是后者没有得到基本的满足 “降低期望不能根本性提高幸福值” 只能维持一段时间 “正确的期望才能获得幸福” 感受幸福的意愿和可能性主要取决于 我们的精神状态 而不是银行存款或其他 关键在于： 改变我们的观念和精神状态 在于改变我们看待这个世界的方式、看待成败的方式 在于我们选择去理解什么、去关注什么 人性 人性是否应该受到限制？ 人性约束观：认为人性无法改变，他是恒定的。我们有特定的本能、偏好，他们是固定不变的；作为一个物种，与生俱来的；我们身上的缺点无法被改变 除了放弃之外，可以选择对其进行引导；建立体制引导缺陷 非人性约束观：认为人性可以不断进步；人性可以得到完善 建立体制完善缺陷、改善缺陷 “成为平凡人” – 人性约束观 生活具有多样性，不是一直都是积极的 不要为了“积极”而积极，这样会付出极大的成本并且往往不遂人意 留给自己一个私人的空间，在这个房间里做一个凡人 “动机悖论”：善于接受自己的情绪，不要过度压抑 情感、行为和认知 情感 &lt;–&gt; 情绪：情绪没有正邪之分；糟糕的情绪亦是人的本性 问题在于：我用什么态度对待和表达情绪？ 行为：表达情绪的方式 这个问题就涉及到道德领域，即有好坏之分；我们可以选择道德或不道德的方式对待其他人 认知：改变自己对糟糕情绪的看法 真诚地面对好坏情绪 “主动接受” 识别好坏的能力 冥想 静坐 注意了转移到呼吸 深呼吸 思考世界和我们的联系、纽带 深呼吸 注意力转移到情绪上，接受你的情绪改变，让你的情绪随呼吸流出","tags":[{"name":"哈佛幸福课","slug":"哈佛幸福课","permalink":"https://wiki.rosuh.me/tags/哈佛幸福课/"},{"name":"笔记","slug":"笔记","permalink":"https://wiki.rosuh.me/tags/笔记/"},{"name":"视频","slug":"视频","permalink":"https://wiki.rosuh.me/tags/视频/"},{"name":"幸福","slug":"幸福","permalink":"https://wiki.rosuh.me/tags/幸福/"}],"categories":[{"name":"软技能","slug":"软技能","permalink":"https://wiki.rosuh.me/categories/软技能/"},{"name":"积极心理学","slug":"软技能/积极心理学","permalink":"https://wiki.rosuh.me/categories/软技能/积极心理学/"}]},{"title":"1 信息、变形和课程简介","date":"2017-11-23T14:15:32.663Z","path":"软技能/积极心理学/1.0-Information-transforation-and-introduction/","text":"01 信息、变形与课程简介2017-8-1 11:36:36 授课对象：对积极心理学有兴趣或者想要变得更开心的人 不需要为了弄清楚某个概念而殚精竭虑，只需要把你觉得对你有用的知识应用到你的生活中 关注点 信息本身而不是信息的传递者 以往“自助运动”的鄙陋 语言上的巨人和行动上的矮子（over-promising and under-delivering） 两个阶段 学术阶段 应用阶段：我如何将这些东西应用到生活中 积极心理学 解释：人本主义心理学 的产物和衍生 人本主义 和其他学派最大的不同是特别强调人的正面本质和价值，而并非集中研究人的问题行为，并强调人的成长和发展，称为 自我实现。 – Wiki 本课程传授的两个重要知识：信息（information）和变形（transformation） 什么是信息 人就像一个容器，接受外界的信息，直到填满整个容器 信息并不能提高人的生存、生活质量 信息是客观的，是多面的 什么是变形 改变容器的形状 让信息为我所用 利用信息 如何解读信息？如何理解以及关注点？ 不止要获取信息，更要挖掘我们自己的潜能 挖掘潜能 “减法比加法更能让人的灵魂成长” “凿去”无用的、功利主义的、浮躁的等等人性弊端 两面性 美好的生活包含成功和失败，或者说是失败之后奋斗的快感 本课程的其中一个目的：让常识更为人所知 本课程的最终内容：让你成为最好的你 保持向上的生活态度，自信并且保持提问 2017-8-1_第一节课 看了想睡觉… 看第一遍的时候没觉得主讲讲了那么多“话”，直到第二遍开始做笔记的时候才发现他有许多重复的观点的地方，可能是为了举多个例子解释吧。 毕竟第一节课，内容实质性不是很强，大多是介绍内容。 上述笔记多是基于快速跳跃而做的笔记，没有一秒一秒地过，难免有一些缺漏。","tags":[{"name":"哈佛幸福课","slug":"哈佛幸福课","permalink":"https://wiki.rosuh.me/tags/哈佛幸福课/"},{"name":"笔记","slug":"笔记","permalink":"https://wiki.rosuh.me/tags/笔记/"},{"name":"视频","slug":"视频","permalink":"https://wiki.rosuh.me/tags/视频/"},{"name":"幸福","slug":"幸福","permalink":"https://wiki.rosuh.me/tags/幸福/"}],"categories":[{"name":"软技能","slug":"软技能","permalink":"https://wiki.rosuh.me/categories/软技能/"},{"name":"积极心理学","slug":"软技能/积极心理学","permalink":"https://wiki.rosuh.me/categories/软技能/积极心理学/"}]},{"title":"2 为什么要学习积极心理学","date":"2017-11-23T14:15:32.663Z","path":"软技能/积极心理学/2.0-The-reason-of-learning-positive-psychology/","text":"2017-8-2 09:28:38 心理学研究的领域的选择，是人类社会心理趋势或关注驱使的一种反映 1967 ~ 2000，消极心理学和积极心理学研究比例将近 21:1 为什么要学习积极心理学？ 研究有效的方法（积极心理学）至关重要：有效的方法对现实具有能动作用 如果我们研究的方法在研究时有效，很大概率上这个方法在日常生活中会更有效 快乐并不只是对痛苦的否定 研究如何培养积极心态是预防焦虑、抑郁等疑难问题最有效的方法 如何研究出有效的方法？（如何探究积极心理学？ 解决方法就在问题本身：特定问题创造特定现实 我们会因为事先的一个问题，然后预设立场；导致在观测客观现实的时候忽略于该问题“无关”的其他东西 比如，夫妻之前总是提问“该如何改善关系”，就会陷入过度放大关系中的缺点而忽略更多的感情的险境中 “吾日三省吾身” –&gt; 避免过度关注缺点 我们应该在关注缺点、消极状态的同时，多关注优点、积极心理 改善眼界 关注优点、设立目标 –&gt; 内心理想主义 注意现实、立刻行动 –&gt; 客观现实主义 利人利己的上升螺旋 承认需要（承认弱点） 接受帮助并帮助他人 善于选择优良的社会帮助 适应力 含义：在复杂、难堪、困难的环境下仍然保持乐观的态度和实干的精神 养成： 一个榜样 “我们要好好树立自己的信念” “我相信你” “你能做好” “你能成功” “你要自己承担生活的责任” “别再埋怨”“别再埋怨社会、老师、父母” 将目光放在长处和优点上并加以培养 自我激励 “如何让自己的大学时光变得更加有意义？” 你要为这段时光负起责任","tags":[{"name":"哈佛幸福课","slug":"哈佛幸福课","permalink":"https://wiki.rosuh.me/tags/哈佛幸福课/"},{"name":"笔记","slug":"笔记","permalink":"https://wiki.rosuh.me/tags/笔记/"},{"name":"视频","slug":"视频","permalink":"https://wiki.rosuh.me/tags/视频/"},{"name":"幸福","slug":"幸福","permalink":"https://wiki.rosuh.me/tags/幸福/"}],"categories":[{"name":"软技能","slug":"软技能","permalink":"https://wiki.rosuh.me/categories/软技能/"},{"name":"积极心理学","slug":"软技能/积极心理学","permalink":"https://wiki.rosuh.me/categories/软技能/积极心理学/"}]},{"title":"5 信念是自我实现的预言","date":"2017-11-23T14:15:32.663Z","path":"软技能/积极心理学/5.0-Faith-is-the-realistic-predictions/","text":"追求幸福 幸福之作用： 幸福让人感觉很好 幸福就是幸福 幸福对我们的生活、我们的人际关系也产生了积极的影响 开拓思路，帮助我们和其他人建立联系，提示自身潜力 “积极情绪的扩展建设理论” 积极情绪似乎会扩展人们暂时的想法，充实行动的库存并建立持久的个人资源 “通过体验积极情绪，人们变得更加富有创造力、更加博学多才、更有韧性、更具社交能力以及更加健康向上” “积极情绪帮助我们客服消极情绪” 当我们被负面情绪所困时，我们的思考变得狭隘和压抑；我们的注意力仅停滞在事情本身 情绪转换 糟糕情绪的 “N &amp; C” 循环 Narrow and Constrict &lt;–&gt; 遭受痛苦 积极情绪的 “B &amp; B” 循环 Broaden and Build &lt;–&gt; 积极情绪 &lt;–&gt; 扩展思路和视野 来源可能是一部喜剧电影、一次深呼吸、一次与朋友间的互动 挑战在于：如何将积极情绪和“允许自己成为普通人”的想法结合起来，去体会情绪，转移情绪；不再不如恶性循环之中 解决问题而非逃避问题 接受自己的糟糕的情绪 选择一种方式转换为积极情绪 这样的过程会提高我们对情绪的调控能力，进而提高我们对糟糕情绪的免疫力；使我们的思路更加清晰和开阔。 追求自我的幸福是自私的行为吗？ 幸福是一个正和博弈 幸福会传染，助人亦助己 自私 ≠ 不道德 传播幸福最好的方式就是经营好自己的幸福 信念是自我实现的预言 信念常常决定我们的行为、决定我们表现的优劣 它是我们成功和幸福最精准的预测 “期待效应” “皮格马利翁”实验 “积极情景创造积极效应” “阿希从众实验” “菲利普津巴多监狱实验” “艾伦·蓝格实验” 巴吉（Barge）研究","tags":[{"name":"哈佛幸福课","slug":"哈佛幸福课","permalink":"https://wiki.rosuh.me/tags/哈佛幸福课/"},{"name":"笔记","slug":"笔记","permalink":"https://wiki.rosuh.me/tags/笔记/"},{"name":"视频","slug":"视频","permalink":"https://wiki.rosuh.me/tags/视频/"},{"name":"幸福","slug":"幸福","permalink":"https://wiki.rosuh.me/tags/幸福/"}],"categories":[{"name":"软技能","slug":"软技能","permalink":"https://wiki.rosuh.me/categories/软技能/"},{"name":"积极心理学","slug":"软技能/积极心理学","permalink":"https://wiki.rosuh.me/categories/软技能/积极心理学/"}]},{"title":"11 习惯","date":"2017-11-23T14:15:32.663Z","path":"软技能/积极心理学/11-habit/","text":"自制力和成功 自制力大小和成功没有必然联系 大部分人的自制力都是固定的，不会发生改变的 仅有自制力比用不足以获得成功、获得改变或获得幸福 “自制力有限假说” &lt;–&gt; 罗伊·鲍迈斯特(Roy Baumeister) 研究 习惯成自然 养成习惯需要定义严谨的行为模式，还要在特定的时间付诸行动、需要以深深扎根的价值观为驱动力 – 托尼·施瓦茨 (Tony Schwartz) 和吉姆·勒尔(Jim Loehr) 成功离不开孜孜不倦的训练和学习 自制力有限所以并非全然依靠自制力去学习或行动 养成习惯之后更容易进行训练和学习 &lt;–&gt; 海明威和达芬奇 将行为养成习惯之后，付出的自制力将大幅降低甚至为 0 早上起床刷牙 运动员长年累月的训练 养成习惯需要足够的自制力 不要尝试在一段时间内养成多个习惯，因为自制力是有限的，这样更容易导致全盘皆输 ​","tags":[{"name":"哈佛幸福课","slug":"哈佛幸福课","permalink":"https://wiki.rosuh.me/tags/哈佛幸福课/"},{"name":"笔记","slug":"笔记","permalink":"https://wiki.rosuh.me/tags/笔记/"},{"name":"视频","slug":"视频","permalink":"https://wiki.rosuh.me/tags/视频/"},{"name":"幸福","slug":"幸福","permalink":"https://wiki.rosuh.me/tags/幸福/"}],"categories":[{"name":"软技能","slug":"软技能","permalink":"https://wiki.rosuh.me/categories/软技能/"},{"name":"积极心理学","slug":"软技能/积极心理学","permalink":"https://wiki.rosuh.me/categories/软技能/积极心理学/"}]},{"title":"3 如何避免惬意的麻木","date":"2017-11-23T14:15:32.659Z","path":"软技能/积极心理学/3.0-how-can-we-get-beyond-the-comfortably-nomb/","text":"惬意的麻木(Confortably numb) 积极心理学主要关注的是健康模式（health model） Saluto-genesis 生理、身体和心理的健康之源在哪？ 健康模式下不同层面的解决方式 缺陷：我们只关注自身的不足 改善：应该给予优点同样程度的关注，将成功和愉悦联系在一起 问题：我们到底擅长什么？如何充分改进？我们的自然倾向是什么？我们将如何度过我们的一生？ 行动：认清兴趣、培养优势以及追求激情 问问自己：生活的意义是什么？我的人生目标是什么？我为什么在这里？我毕业之后想做什么？ 培养积极心理（乐观、目的性、意义等）等同于增强心理免疫能 积极心理学的基础（本课程的前提 搭建桥梁：不同学科、学术和社会等 幸福与否不知取决于外界因素，更多的是个人理解和感受世界的能力 承认人性的缺漏还是从心理层面完善他？ 幸福是并且应当是我们的最终追求和道德追求 桥梁 世界需要 具有实践精神的理想主义者(practical idealists) 相信改变是会发生的 理论和实践之间有很多代沟 教师和学生：马福·科林斯计划，皮革马利温效应 如何赞扬别人和提高自信？如何培训自我效能？ 瑜伽能减少入狱人员的重新犯罪几率 冥想可以改变大脑，提高人对消极情绪的抵抗能力 每周进行 3 次 /30min 以上的运动与现最有效的心理药物效果是一样的 解决矛盾的方法不只是创造接触（双方见面交流），更要创建一个只有双方努力才能达到的目标 考虑实际，消除象牙塔和社会之间的隔阂 作为学生要承担起上述责任 “生长锥统计学” 研究一般情况有助于观察当下，但无助于改善当下 研究基因演变最激烈的地方，这样我们可以知道最可能发生的可能 心理学上的作为“普通”，实际上是“平均精神状态” 这一概念会导致全体精神状态下降 与“精英主义”的区别 研究最优秀的人同时也研究普通的人 研究最优秀的人对所有人是有益的","tags":[{"name":"哈佛幸福课","slug":"哈佛幸福课","permalink":"https://wiki.rosuh.me/tags/哈佛幸福课/"},{"name":"笔记","slug":"笔记","permalink":"https://wiki.rosuh.me/tags/笔记/"},{"name":"视频","slug":"视频","permalink":"https://wiki.rosuh.me/tags/视频/"},{"name":"幸福","slug":"幸福","permalink":"https://wiki.rosuh.me/tags/幸福/"}],"categories":[{"name":"软技能","slug":"软技能","permalink":"https://wiki.rosuh.me/categories/软技能/"},{"name":"积极心理学","slug":"软技能/积极心理学","permalink":"https://wiki.rosuh.me/categories/软技能/积极心理学/"}]},{"title":"6 乐观","date":"2017-11-23T14:15:32.659Z","path":"软技能/积极心理学/6.0-positive/","text":"如何创建积极的环境 相信改变会发生，相信即便微小的难以记住的东西也会对心理产生极大的暗示。 欣赏你爱的人的图片 欣赏美好的事物 在目力所及的地方放上令你感觉温暖、能让你感受到爱和友善的东西 名人名言 音乐、电影 自我效能的力量 “思考只是成功定律的一部分” 成功离不开自我效能、艰苦奋斗和不断的失败 “自我效能决定命运” 自我效能：用于衡量个体本身对完成任务和达成目标能力的信念的程度或强度 “安慰剂效应” 如何平衡期许和现实 两种调节机制 动力（motivation）： 如果相信在某方面能做得更好，你更有可能做得更好 统一性（consistency） 人们会对世界产生 心理图式 自我图式 （self-schema）是指一个长期及稳定的 记忆 ，内容是有关在特定行为领域下的 信念 、 经验 及对 自我 的总括；也作“过去知识和经验的表征形式” 比如我们“知道”，如果把东西留着半空中，这个东西“就会掉下来” 比如“主观印象” 心理图式对应的“客观世界” 比如，留在半空中的东西确实掉下去了，是为客观事实 大脑不善于接受现实和理想之间的差距 甚至会逃避、忽视这样的差距 为了让两者保持统一，要么 改变客观事实 ， 要么改变自己的想法 修复现实和理想的裂痕 更新我们的主观想法 屏蔽客观信息 主动证实信息 创造一个新的现实 我们经常使用的是第二和第三种方法，因为我们不愿意“更新”我们的最初的想法，所以一旦发生了不符合我们预期的事情，我们会选择性忽略（不更新，屏蔽客观信息），然后去寻找支持我们原来想法的证据（主动证实信息）。 比如，我们以前认为小明是坏人。而小明最近几天一直在做好事，有很多人不善于接受新的改变，而持有一种观点“小明以前做过什么坏事”，然后去证实这件事。 也即是“问题创造现实”。这样的情况可以被避免。只要我们 不要忽略掉积极的事情，并且小心求证消极的事情。 客观现实的主观解释 失败 –&gt; 成功证明某事不成功 成功 –&gt; 成功 信念的功用 “我相信” –&gt; “我会更努力工作” √ “我相信” –&gt; “会成功” × 简言之：信念是为了更好地工作 “失败和成功的次数一样多” 迪安·西蒙顿（Dean Simonton）的研究：历史上最成功的科学家和艺术家也同样是那些失败最多次的 注意逻辑关系！失败最多次并不代表就会变成最成功的 失败的功用 成功需要行动 –&gt; 行动会产生失败 –&gt; 失败是不可避免的 不断从失败中汲取经验 目标设立 积极和悲观主义者的区别 悲观主义者：无论长期或是短期，其设立的目标都很现实 期望值不高, 信念不强 –&gt; 可能做得不好 &lt;-(思维一致性)-&gt; 调低目标难度 表现平平：“我早就说过我做不好” &lt;–&gt; “是的，你早就说过了，你真实在” 表现优秀：“我这次可能是瞎猫碰上死耗子”“用尽了我一生的运气” 乐观主义者：短期目标 天马行空，长期目标比较现实 期望值高，动力十足 –&gt; 我能做得很好 &lt;–(思维一致性)–&gt; 调高目标难度 表现平平：“我能从中学到什么？”“这是一次机会” &lt;–&gt; “为什么你就不能实际一点呢？稍微和 xx 学习一下吧” &lt;–&gt; 保持高度积极和高动力，不断努力直到把不可能化为可能 解释客观现实 悲观主义者：将负面情况看成普遍现象 “这一次没有成功，我不可能成功”“我就是这样的人” “要么行，要么不行” 乐观主义者：现实可以被学习并改变 “我可以从中学到什么？” “这是一次机会” 心理健康与生理健康 客观事实解释角度会影响人体的免疫系统和复原力水平 乐观的等级 如何分辨现实与非现实？ 斯托克代尔悖论（Stockdale Paradox）：不要把最终胜利的信念和现实的磨练这个两个因素混淆起来，其中前者 必不可少，而后者无论如何都要接受 成功：乐观、激情和勤奋 乐观：相信自己能成功 激情：对所做事业充满激情 勤奋：努力地工作 –&gt; “勤奋没有替代品” 高期望和失望？ 为什么人不互相鼓励追求高的目标？ 害怕伤及我们的自尊 &lt;–&gt; “期望和现实的比值为幸福值” &lt;–&gt; 期望低，幸福值高 （×） 幸福有自己的稳态 “现实不如期望” &lt;–&gt; 幸福感降低 (√) &lt;–( 一段时间)–&gt; 幸福感恢复（√） “现实优于期望” &lt;–&gt; 幸福感升高 (√) &lt;–( 一段时间)–&gt; 幸福感恢复（√） “稳态的缺点” 幸福感是固定的吗？是由我的基因决定的吗？我无法一直提升我的幸福感吗？ 提升你的基础幸福感：解决问题而不是逃避问题 解决问题：允许自己冒险，处于“学习区”中，承担失败的风险；处理、解决以及直面你的问题 依据？ 自我认知：“我们使用同一种方法来判断自己和他人” 你不敢做的事，不敢尝试的事情，往往会给与之高的评价，一旦自己做了，也会给自己高度评价 比如，发表演讲、争取权利等等","tags":[{"name":"哈佛幸福课","slug":"哈佛幸福课","permalink":"https://wiki.rosuh.me/tags/哈佛幸福课/"},{"name":"笔记","slug":"笔记","permalink":"https://wiki.rosuh.me/tags/笔记/"},{"name":"视频","slug":"视频","permalink":"https://wiki.rosuh.me/tags/视频/"},{"name":"幸福","slug":"幸福","permalink":"https://wiki.rosuh.me/tags/幸福/"}],"categories":[{"name":"软技能","slug":"软技能","permalink":"https://wiki.rosuh.me/categories/软技能/"},{"name":"积极心理学","slug":"软技能/积极心理学","permalink":"https://wiki.rosuh.me/categories/软技能/积极心理学/"}]},{"title":"7 逆境和机遇","date":"2017-11-23T14:15:32.659Z","path":"软技能/积极心理学/7.0-adversity-or-chance/","text":"如何变得更加乐观 1. 付诸行动 基于 艾伯特·班杜拉(Albert Bandura) 的研究 不顾事实的夸奖会对目标产生伤害 诸如早上起床对镜子里的自己说十句赞美自己的话之类的 一味夸奖不如 付诸行动 努力和解决问题是通向成功的唯一途径：通过努力和实践会取得更大的成功 “让人看到自己的努力，看到自己步入正轨” 苏林·祁克果(Soren Kierkegarrd) –&gt; “敢于尝试只会暂时失去立足处，不敢尝试将失去自我” 2. 想象：把目标呈现在心中 基于 斯蒂芬·科斯林(Stephen Kosslyn) 的研究 “大脑可能分不清楚真实事物和想象事物的区别” “模拟练习” 引入各种器官，以便使想象更加地真实 3. 认知疗法 马丁·塞利格曼(Martin Seligman), 阿伦·贝克(Aaron Temkin Beck) “感情受思想的驱动” Event –&gt; Evaluation(thought) –&gt; Emotion 如果要想改变情绪，要从想法开始改变 “重建理性和真实” 3Ms 学说 3Ms：三个导致非理性思想的陷阱 夸大理论：夸张了已发生的事实 &lt;–&gt; 归纳法与过度归纳 归纳法：从已知的事情，来判断未知的类似的事情 –&gt; “这次干得不好” &lt;–&gt; “可能哪里出了问题” 过度归纳：“这次干得不好” &lt;–&gt; “我很蠢，这类事做不好” &lt;–&gt; “不成功便成仁” 缩小理论：狭隘视野 将注意力集中在某一个个体、个例上面 伪造、捏造和情绪化推断 推卸责任 “没人回来帮你把生活过得更美好，你必须承担起生活的责任” “情绪不是现实，情绪只是对现实的推断” 看清以及理性分析现实 作出正确的评估 实践 我的结论是否贴合现实？ 它是否理性？ 我是否忽略了重要的（现实）因素？ 我仍需要考虑什么重要因素？ “我在哪里扭曲了事实？” “我在哪里扭曲了自己的评价？扭曲了自己的思想？从而导致了不必要的负面情绪” 危机和机遇 几乎所有杰出的人，都是经历过巨大的考验才成就辉煌 挖掘苦难中的价值","tags":[{"name":"哈佛幸福课","slug":"哈佛幸福课","permalink":"https://wiki.rosuh.me/tags/哈佛幸福课/"},{"name":"笔记","slug":"笔记","permalink":"https://wiki.rosuh.me/tags/笔记/"},{"name":"视频","slug":"视频","permalink":"https://wiki.rosuh.me/tags/视频/"},{"name":"幸福","slug":"幸福","permalink":"https://wiki.rosuh.me/tags/幸福/"}],"categories":[{"name":"软技能","slug":"软技能","permalink":"https://wiki.rosuh.me/categories/软技能/"},{"name":"积极心理学","slug":"软技能/积极心理学","permalink":"https://wiki.rosuh.me/categories/软技能/积极心理学/"}]},{"title":"8 感激","date":"2017-11-23T14:15:32.655Z","path":"软技能/积极心理学/8.0-appreciate/","text":"是什么阻止我们乐观？舆论是乐观的杀手 媒体的职能之一就是突出那些本可以被纠正的错误，并发动大家一起去纠正，去改善。 媒体报道那些糟糕的、负面的信息，加上现在信息过载，加剧了负面信息的传播 这是媒体的责任亦是媒体的“偏见” 过度聚焦负面信息只会加剧负面情绪 让人对现实产生负面联系 过度报道某大公司非法交易 –&gt; 你想变得成功吗？那就得坑蒙拐骗 过度报道政客丑闻 –&gt; 政客都是骗子 “我们需要直面现实，直面负面消息的存在” 感激 发自肺腑的感激能让积极情绪升值 感激帮助我们创造更积极的环境 感激能创造“积极情绪的螺旋上升” 适应性 对负面、异常情况的警觉是生存的本能 对异常情况产生适应性亦是生存本能 不要对生活“习以为常” 不要认为那些平常的事物是“理所当然”的 寻找值得感激的事物 让自己更多地关注与生活中美的、积极的事物上 感激自己身上、周围值得感激的事物 养成寻找幸福和感激 的习惯 一旦我们学会感激，我们就不会变得“理所当然” 行动 感受每一天 “你通常干什么事情会不由自主地专心致志？” 认真地去做这些事情，不只是做这些事，同时你还在感激生活 在每晚睡前写下五件让你感激的事物 如何解决“习以为常”？当这件事已经失去新鲜感之后呢？当这件事已经变成例行公事之后呢？ 解决方法： 引入多种多样的人和事物 同样的事情多角度描写 艾伦·朗格 –&gt; “用心法则”：用心 –&gt; 创造新的区别 用心观察，专注于此，发现新的区别 从专注中保持新鲜感 词语形象化 善用你的眼睛吧，犹如明天你将遭到失明的灾难；聆听乐曲的妙音，似乎你明天就会失聪。抚摸每一件你想要抚摸的物品吧，犹如你明天的触觉将会衰减。嗅闻每一件你想要抚摸的物件 吧，犹如你明天即将失去嗅觉和味觉一样。 – 海伦·凯勒","tags":[{"name":"哈佛幸福课","slug":"哈佛幸福课","permalink":"https://wiki.rosuh.me/tags/哈佛幸福课/"},{"name":"笔记","slug":"笔记","permalink":"https://wiki.rosuh.me/tags/笔记/"},{"name":"视频","slug":"视频","permalink":"https://wiki.rosuh.me/tags/视频/"},{"name":"幸福","slug":"幸福","permalink":"https://wiki.rosuh.me/tags/幸福/"}],"categories":[{"name":"软技能","slug":"软技能","permalink":"https://wiki.rosuh.me/categories/软技能/"},{"name":"积极心理学","slug":"软技能/积极心理学","permalink":"https://wiki.rosuh.me/categories/软技能/积极心理学/"}]},{"title":"9 积极情绪","date":"2017-11-23T14:15:32.655Z","path":"软技能/积极心理学/9.0-positive-emotions/","text":"处理痛苦和积极情绪 基于 桑佳·吕波密尔斯基（Sonja Lyubomirsky）的研究 痛苦情绪表达 写、说更能化解痛苦情绪 在脑海中回忆会加剧痛苦情绪 积极情绪 说和写反而减弱积极情绪的持续化 回忆能让积极情绪变得更多 分析和重现情绪 分析经历有助于改善痛苦以及消极经历 而分析美好的经历并不能增加很多积极情绪 回忆积极情绪能让积极情绪持续更久 单纯在脑海里思考只会让该消极情绪更甚 PTSD 发生的区域调查 感激练习就是重现经历的练习","tags":[{"name":"哈佛幸福课","slug":"哈佛幸福课","permalink":"https://wiki.rosuh.me/tags/哈佛幸福课/"},{"name":"笔记","slug":"笔记","permalink":"https://wiki.rosuh.me/tags/笔记/"},{"name":"视频","slug":"视频","permalink":"https://wiki.rosuh.me/tags/视频/"},{"name":"幸福","slug":"幸福","permalink":"https://wiki.rosuh.me/tags/幸福/"}],"categories":[{"name":"软技能","slug":"软技能","permalink":"https://wiki.rosuh.me/categories/软技能/"},{"name":"积极心理学","slug":"软技能/积极心理学","permalink":"https://wiki.rosuh.me/categories/软技能/积极心理学/"}]},{"title":"10 改变","date":"2017-11-23T14:15:32.651Z","path":"软技能/积极心理学/10-change/","text":"改变如何发生？改变的生物学原理 神经可塑性（neural plasticity） 神经发生 突触可塑性 理解人脑内思考和记忆时，神经突触之类的建立和产生： 挖掘新的神经链接 拓宽已有的神经链接 是否要进行改变？ 性格是相对的 苛刻和严谨 轻信和信赖 潜意识有可能对某个性格的伴生点有依赖性 不愿意放弃严谨的态度，但是容易造成对事物过于苛刻的情况 比如焦虑和责任感相伴生 潜意识的联系和社会要求以及自我实现有关 不愿意对别人说“不”，可能是希望获得一个“善解人意、有同理心”的社会评价 无法摆脱放松和获得幸福的冲突，可能是潜意识倾向于“幸福需要经过苦难、人不能不劳而获”的思维习惯 改善想法 理解思维的误区 要清除“两者”的区别 “自己想要什么”？ 通过不断的 自我询问 来获得对已有习惯性思维的新的理解，摆脱麻木，获得新的体验。 什么能被改变？基于 艾德·狄纳(Ed Denier) 和 桑佳·吕波密斯基(Sonja Lyubomirsky) 的研究 我们要改变什么？我们能改变什么？不能改变什么？ 个体幸福感分析 基因设定范围（×） “ 50% ” 对于与生俱来的东西我们要接受并充分利用好他 幸福水平只有一部分取决于基因 外部环境（×） “ 10% ” 极端社会环境比如社会制度 受意识行为支配的那部分（√） 行为处事方式、思想、世界观以及我们的生活重心 改变的两种方式 在两种方式下，均会和之前 讲到的 A B C 模式相对应： A ：情感，情绪 B ：行动 C ：思想 逐渐改变 A：冥想（基于 乔恩·卡巴泽（Jon Kabat-Zin）的研究 ） 锻炼冥想能力可以引领我们达到身心舒展、内心平和以及自我审视的更高境界 B：“肢体反馈假说” 心理态度和行为的关系 大脑的一致性：其中一个改变，必须保持同步；要么回落已提升的态度，要么提高现有的行为 习惯是习惯性行为，行为是情绪的一个一致性体现 如果不做出行为上的改变，任何心理、知识提升都将被拉回原来的水平 学习新知识亦是同理 细分而言的坐姿、表情、走路姿态等等都会反过来影响情绪；亦会想周围环境传递消息 C：认知重构 对事物的解释角度决定了接受的信息 积极接受 &lt;–&gt; 将苦难看做挑战 积极 接受那些坏的消息、情绪 适当表现出来 对恢复如初满怀希望 激进改变 A：PTSD 与 “高峰体验理论” PTSD 是激进改变的绝佳论证，同时伴随的“创伤后成长”理论亦是一种益处 “高峰体验假说”：人生最美好的时刻，是瞬间强烈的幸福感，甚至是对欣喜若狂、如痴如醉、欢乐至极的浓缩。这样的体验来自于高深的美学体验，比如创作的喜悦、美好的爱情、完美的性爱、亲子间的关怀、自然分娩以及其他众多体验 保持“高峰体验”的后续情绪 B 直面风险和自己不情愿做的事情 &lt;–&gt; 跳出舒适区、进入学习区 C：顿悟体验（eureka experience） 前期准备阶段：沉浸的思想体验 中期休息阶段：间断性思考的重要性 活力爆发：顿悟体验 评估阶段：实验、实践然后评估理论正确性","tags":[{"name":"哈佛幸福课","slug":"哈佛幸福课","permalink":"https://wiki.rosuh.me/tags/哈佛幸福课/"},{"name":"笔记","slug":"笔记","permalink":"https://wiki.rosuh.me/tags/笔记/"},{"name":"视频","slug":"视频","permalink":"https://wiki.rosuh.me/tags/视频/"},{"name":"幸福","slug":"幸福","permalink":"https://wiki.rosuh.me/tags/幸福/"}],"categories":[{"name":"软技能","slug":"软技能","permalink":"https://wiki.rosuh.me/categories/软技能/"},{"name":"积极心理学","slug":"软技能/积极心理学","permalink":"https://wiki.rosuh.me/categories/软技能/积极心理学/"}]},{"title":"积极心理学资料索引与声明","date":"2017-11-23T14:15:30.956Z","path":"软技能/积极心理学/积极心理学资料索引与声明/","text":"《积极心理学》 系列 笔记 ，是笔者个人的学习记录摘抄。 其中主要的参考资料是（文章中将不再列出，除非特殊来源）：哈佛大学公开课：幸福课 多数结论、文字皆为摘抄自视频中，少数为笔者自己的总结。 本系列的文章内容架构为笔者自行梳理。 多数图片为笔者自行制作，少数来自网上或公开的资料 如果本系列文章有侵犯到您权利的地方，请立刻联系笔者！","tags":[{"name":"哈佛幸福课","slug":"哈佛幸福课","permalink":"https://wiki.rosuh.me/tags/哈佛幸福课/"},{"name":"笔记","slug":"笔记","permalink":"https://wiki.rosuh.me/tags/笔记/"}],"categories":[{"name":"软技能","slug":"软技能","permalink":"https://wiki.rosuh.me/categories/软技能/"},{"name":"积极心理学","slug":"软技能/积极心理学","permalink":"https://wiki.rosuh.me/categories/软技能/积极心理学/"}]},{"title":"华为 A199 救砖札记","date":"2017-11-21T09:07:36.921Z","path":"玩机技巧/save-blocked-in-A199/","text":"1. 前言 这货之前一直被我丢在柜子里。晚上想要注册多一个微信号，需要多一台设备来登陆。毕竟双开有被封号的风险。 之前已经刷入了第三方的 REC，所以本以为挺简单。想着先刷回官方版本，然后自己精简的。 于是安装官方的指引： 官方的包解压出来，把 dload 放到了外置 SD 卡 设置–&gt; 关闭快速启动 设置–&gt; 关于手机–&gt; 系统更新–&gt; 本地升级 重启 然后就崩了… 第三方的 REC 无法识别，然后一直卡在 TWRP 的界面，重启或者试图进入 REC 都会一直卡在 TWEP 启动界面。 然后在官方论坛找了一下，没什么有用的帖子…刷机氛围真是不行… 直到看到某个官方教程帖子里说，华为的 fastboot 界面其实就是开机界面（麦芒 A199 的就是那个麦芽）。使用 音量键减 + 开机键 进入。 能进入 fastboot 说明还是有救的。 2. 环境准备 2.1 安装驱动 我使用的是 Win10，需要安装华为的驱动之后才能识别设备，不然 fastboot 是无法查找到设备的。 关键词搜索：麦芒 A199 华为官方的搜索界面都找不到这机子了…滑到列表最下面，看到 HUAWEI Stick UTPS-V200R003B015D11SP01C983(for win10) 这个选项： 然后下载下来。如果官方撤了这个文件，可以到我分享的度盘下载： 1链接: http://pan.baidu.com/s/1dFadWkT 密码: bdyd 下载之后解压再解压，里面是一个 iso 镜像文件，可以选择装载到你的虚拟驱动器，或直接解压出来都没问题。 打开 AutoRun.exe 安装，就行了。 照道理现在应该已经装好了。我就是这么装的，并且之前我的系统也没有装过华为的其他驱动，所以我判断这样应该就可以。 2.2 刷入 REC 获取 ADB 套件 这一步需要用到 adb 套件。 点击下面的链接从 Google 官方下载： https://dl.google.com/android/repository/platform-tools-latest-windows.zip 如果因为某些 不可描述 的原因导致你无法下载，可以通过我分享的度盘链接下载： 1链接: http://pan.baidu.com/s/1miQCxnU 密码: kyum 建议从官方下载，保证取得最新版的套件。 下载之后解压出来，得到 adb套件。 获取官方的 REC 麦芒的官方 REC 我在论坛没找到。所以需要从官方的 ROM 中提取出来。 下面是提取的步骤，如果你不想自己提取，可以直接用我提取出来： 1链接: http://pan.baidu.com/s/1eRO689O 密码: q4f9 官方 ROM 下载 如果官方撤掉了，从我的盘下载： 1链接: http://pan.baidu.com/s/1c21kqDq 密码: pi7u 提取 REC 需要用到一个提取软件，直接点下面下载： 1链接: http://pan.baidu.com/s/1boDhujH 密码: 5kun 下载完解压出来，双击运行HuaweiUpdateExtractor.exe。 选择 Update File 右边的按钮选择官方 ROM 选择 ROM 之后，右键单击 RECOVERY 解压出来： 然后把解压出来的 RECOVERY 放到第一步中 ADB 套件的文件夹中。 刷入 REC 进入 ADB 套件文件夹，可以看到诸如 adb, fastboot 等工具。 按住键盘的 Shift 键，同时鼠标右键单击该文件夹的空白处，选择“在此处打开命令行窗口”： 我这里是 Powershell 窗口，大部分时候显示为 cmd 窗口。 按住手机 音量键减 + 开机键 进入 fastboot 模式，显示为开机的那个麦芽 logo。 进入命令行界面，输入以下命令检查设备是否链接： 1fastboot.exe devices 如果有输入提示（一般是含有一串数字 + 英文字母），则意味着设备已经被识别了。如果没什么输出、提示，则意味着没有被识别。那么你要自行寻找其他驱动。 接着输入以下命令，进行刷入 REC 1fastboot.exe flash recovery RECOVERY.img 输入回车之后应该就开始刷入了。命令行窗口会有提示： 由于我之前是升级过程卡住了，刷入 REC 之后自动开始了流程，这点还是很赞的： 接着就可以进行愉快地玩耍啦~ Best Wish. by rosu 2017-3-16","tags":[{"name":"Android","slug":"Android","permalink":"https://wiki.rosuh.me/tags/Android/"},{"name":"huawei","slug":"huawei","permalink":"https://wiki.rosuh.me/tags/huawei/"},{"name":"A199","slug":"A199","permalink":"https://wiki.rosuh.me/tags/A199/"}],"categories":[{"name":"玩机技巧","slug":"玩机技巧","permalink":"https://wiki.rosuh.me/categories/玩机技巧/"}]},{"title":"Ubuntu 安装软件合集","date":"2017-11-11T03:40:38.644Z","path":"Linux-VPS/softwares/","text":"记录 Ubuntu 平台下安装的部分软件。awesome-linux-software Node.js &amp; 版本管理 推荐的安装方式是通过 nvm 123456789101112131415curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash# verify installtioncommand -v nvm# printnvm# install nodejsnvm install node# special in o-my-zsh# install as plugingit clone https://github.com/lukechilds/zsh-nvm~/.oh-my-zsh/custom/plugins/zsh-nvm# edit ~/.zshrcplugins+=(zsh-nvm) nvm S-S-Libev123456789101112131415161718192021222324# 提示 add-apt-repository: command not found# 安装工具包 apt-get install software-properties-common# 安装 libevsudo add-apt-repository ppa:max-c-lv/shadowsocks-libevsudo apt-get updatesudo apt install shadowsocks-libev# 启动时提示 This system doesn't provide enough entropy to quicklygenerate high-quality random numbers# 安装 rng-tools 工具 apt install rng-tools# 4 in 1wget --no-check-certificate -O shadowsocks-all.shhttps://raw.githubusercontentcom/teddysun/shadowsocks_install/master/shadowsocks-allshchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log KeePass212apt install keepass2 Uget1234sudo add-apt-repository ppa:plushuang-tw/uget-stablesudo apt updatesudo apt install uget Oracle Java1234567# 清除已经安装的 OpenJDKsudo apt-get purge openjdk-\\*# 安装 Oracle JDKsudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installer how to install java with apt get on ubuntu 16.04 Chrome12wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.debsudo dpkg -i google-chrome-stable_current_amd64.deb Typora1234567# optional, but recommendedsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE# add Typora's repositorysudo add-apt-repository'deb https://typora.io ./linux/'sudo apt-get update# install typorasudo apt-get install typora you-get12345678# install ffmpegsudo add-apt-repository ppa:mc3man/trusty-mediasudo apt updatesudo apt install ffmpeg# install you-getpip3 install you-get#usageyou-get url Guake 终端 12sudo add-apt-repository ppa:webupd8team/unstablesudo apt-get update 到 Github 页面下载最新版本并解压，之后执行 1./dev.sh --install Guake BBR123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh Coursera-dl123pip3 install coursera-dl# sometime you need to restart your shellexec $SHELL Firefox beta123sudo add-apt-repository ppa:mozillateam/firefox-nextsudo apt-get updatesudo apt-fast install firefox Telegram123sudo add-apt-repository ppa:atareao/telegramsudo apt-get updatesudo apt-fast install telegram Wechat 微信 electronic-wechat 网易云 魔改版 ieaseMusic 电源管理 12sudo apt-fast install tlp tlp-rdwsudo tlp start 系统监视器 12345sudo apt-get install python3-psutil curl git gir1.2-appindicator3-0.1git clone https://github.com/fossfreedom/indicator-sysmonitor.gitcd indicator-sysmonitorsudo make installnohup indicator-sysmonitor &amp; indicator-sysmonitor","tags":[{"name":"Linux","slug":"Linux","permalink":"https://wiki.rosuh.me/tags/Linux/"},{"name":"VPS","slug":"VPS","permalink":"https://wiki.rosuh.me/tags/VPS/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://wiki.rosuh.me/tags/Ubuntu/"}],"categories":[{"name":"Linux & VPS","slug":"Linux-VPS","permalink":"https://wiki.rosuh.me/categories/Linux-VPS/"}]}]}