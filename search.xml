<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[7 UI Fragmnet 与 fragment 管理器]]></title>
      <url>/Android-%E5%BC%80%E5%8F%91/7-UI-Fragment-and-fragmen-manager/</url>
      <content type="html"><![CDATA[<h1 id="7-1-UI- 设计的灵活性需求"><a href="#7-1-UI- 设计的灵活性需求" class="headerlink" title="7.1 UI 设计的灵活性需求"></a><u>7.1 UI 设计的灵活性需求</u></h1><ul>
<li><u>复杂的用户界面呈现需求</u><ul>
<li><u>平板以及大尺寸手机显示问题</u></li>
<li><u>滑动屏幕等交互问题</u></li>
</ul>
</li>
<li><u>acticity 视图局限性</u><ul>
<li><u>我们需要 activity 界面可以在运行时组装甚至时重新组装，但是其本身并不具备这样的灵活性</u></li>
<li><u>activity 还得和特定的用户界面紧紧绑定</u></li>
</ul>
</li>
</ul>
<h1 id="7-2- 引入 -fragment"><a href="#7-2- 引入 -fragment" class="headerlink" title="7.2 引入 fragment"></a><u>7.2 引入 fragment</u></h1><ul>
<li><u>fragment 是一种控制器对象</u><ul>
<li><u>activity 可以委托它执行任务</u><ul>
<li><u>这些任务通常是管理用户界面</u></li>
<li><u>受管的用户界面可以时一整屏或时整屏的一部分</u></li>
</ul>
</li>
<li><u>采用 fragmnet 来管理 UI，可以绕开 android 系统 activity 使用规划的限制</u></li>
</ul>
</li>
<li><u>管理用户界面的 fragment 又称为 UI fragment</u><ul>
<li><u>它自己也有产生于布局文件的视图</u></li>
<li><u>fragment 视图包含了用户可以交互的可视化 UI 元素</u></li>
</ul>
</li>
<li><u>activity 视图能预留位置供 fragment 视图插入</u><ul>
<li><u>多个 fragment 则需要预留多个位置以供插入</u></li>
</ul>
</li>
<li><u>activity 视图和 fragment 的关系和切换如下</u></li>
</ul>
<p><u><img src="https://img.rosuh.me/wiki/wiki_2017_1.png" alt="明细 fragment 的切换"></u></p>
<ul>
<li><u>fragment 可以带来灵活多变的布局，代价就是复杂的应用、更多的组件以及大量实现的代码</u></li>
</ul>
<h1 id="7-3- 着手开发示例应用"><a href="#7-3- 着手开发示例应用" class="headerlink" title="7.3 着手开发示例应用"></a><u>7.3 着手开发示例应用</u></h1><p><u><em>CriminalIntent 就是本示例应用的名称咯。</em></u></p>
<p><u>我们先来梳理一下开发流程。</u></p>
<h5 id="我们先来看一下整个 CriminalIntent 项目的对象图解，以便我们更好地理解开发流程"><a href="# 我们先来看一下整个 CriminalIntent 项目的对象图解，以便我们更好地理解开发流程" class="headerlink" title="我们先来看一下整个 CriminalIntent 项目的对象图解，以便我们更好地理解开发流程"></a><u>我们先来看一下整个 <code>CriminalIntent</code> 项目的对象图解，以便我们更好地理解开发流程</u></h5><p><u><img src="https://img.rosuh.me/wiki/wiki_2017_d.png" alt="项目对象图解"></u></p>
<p><u><strong>解析</strong>：</u></p>
<ul>
<li><u><code>CrimeFragment</code>的作用与 <code>activity</code> 在<code>GeoQuiz</code>应用中的作用差不多，都是负责创建并管理用户界面，以及与模型对象进行交互</u></li>
<li><u><code>Crime</code>实例代表某种办公室陋习</u><ul>
<li><u><code>crime</code>有一个标题、一个标志 ID，一个日期和一个布尔值</u></li>
<li><u>布尔值用来表示陋习是否被解决</u></li>
<li><u>简单起见，本章使用一个 <code>Crime</code> 实例，并将其存放在 <code>CrimeFragment</code> 类的成员变量 <code>mCrime</code> 中</u></li>
</ul>
</li>
<li><u><code>CrimeActivity</code>视图（其对应的 <code>.xml</code> 文件）由 <code>FragmentLayout</code> 组件组成，<code>FragmentLayout</code>组件为 <code>CrimeFragment</code> 视图安排了显示位置</u></li>
<li><u><code>CrimeFragment</code>视图由一个 <code>LineaLayout</code> 组件及其三个子视图组成；<code>CrimeFragment</code>类中由存储它们的成员变量，并设有监听器，会响应用户操作，更新模型数据</u><ul>
<li><u><code>EditText</code></u></li>
<li><u><code>Button</code></u></li>
<li><u><code>CheckBox</code></u></li>
</ul>
</li>
</ul>
<h4 id="CrimeFragment"><a href="#CrimeFragment" class="headerlink" title="CrimeFragment"></a><u>CrimeFragment</u></h4><ul>
<li><u>首先设计一个名为 <code>CrimeFragment</code> 的 UI  fragment 来管理用户界面</u></li>
<li><u>再设计一个名为 <code>CrimeActivity</code> 的 activity 来托管 <code>CrimeFragment</code> 实例</u><ul>
<li><u>activity 在其视图层内提供一处位置，用来放置 <code>fragment</code> 视图</u></li>
<li><u><code>fragment</code>视图本身没有在屏幕上显示视图的能力；只有将它放置在 activiti 视图层级结构中，<code>fragment</code>视图才能显示在屏幕上</u></li>
</ul>
</li>
</ul>
<p><u><img src="https://img.rosuh.me/wiki/wiki_2017_4.png" alt="CrimeActivity 托管 CrimeFragment"></u></p>
<h4 id="两类 -fragment"><a href="# 两类 -fragment" class="headerlink" title="两类 fragment"></a><u>两类 fragment</u></h4><ul>
<li><u>原生版本的<code>fragment</code></u><ul>
<li><u>内置于设备系统中，如果应用要支持各个系统版本，在不同设备上运行的 <code>fragment</code> 可能会有不同的表现（因为各个版本的维护有差异）</u></li>
</ul>
</li>
<li><u>支持库里的<code>fragment</code></u><ul>
<li><u>发布时，内置于应用中；使用支持库的 <code>fragment</code> 在不同设备上都会由相同的表现</u></li>
<li><u>我们使用的支持库版本来自 <code>AppCompat</code> 库</u></li>
</ul>
</li>
</ul>
<p><u>一般选用支持库中的 <code>fragment</code> 实现，因为考虑到 <code>fragment API</code> 不断引入新特性以及支持库不断更新的现状。</u></p>
<h4 id="在 -Android-Studio- 中增加依赖关系"><a href="# 在 -Android-Studio- 中增加依赖关系" class="headerlink" title="在 Android Studio 中增加依赖关系"></a><u>在 Android Studio 中增加依赖关系 </u></h4><p><u> 要使用 <code>AppCompat</code> 库，项目必须加入依赖关系：</u></p>
<ul>
<li><u>打开应用模块的 <code>build.gradle</code> 文件</u><ul>
<li><u><code>app/build.gradle</code></u></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">implementation <span class="title">fileTree</span><span class="params">(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span></span></span><br><span class="line"><span class="function">    implementation 'com.android.support:appcompat-v7:26.1.0'</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p><u><em>Android Studio 在 <code>build.gradle</code>中将原来的 <code>compile</code>改为了 <code>api</code>和<code>implementation</code>。</em></u></p>
<p><u>参看：<a href="https://stackoverflow.com/questions/44402024/why-android-change-compile-task-to-implementation-task-in-gradle-build" target="_blank" rel="external">Why Android change ‘compile’ task to ‘implementation’ task in gradle build?</a></u></p>
<p><u>接着我们先创建模型层的 <code>Crime</code> 类。</u></p>
<h4 id="创建 Crime 类"><a href="# 创建 Crime 类" class="headerlink" title="创建 Crime 类"></a><u>创建 <code>Crime</code> 类</u></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Crime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UUID mId;</span><br><span class="line">    <span class="keyword">private</span> String mTitle;</span><br><span class="line">    <span class="keyword">private</span> Date mDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mSolved;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Crime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mId = UUID.randomUUID();</span><br><span class="line">        mDate = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 略去 getter() 和 setter() 方法</span></span><br></pre></td></tr></table></figure>
<p><u><em>解析</em>：</u></p>
<ul>
<li><u><code>UUID</code>类是 Android 框架里的 Java 工具类</u><ul>
<li><u>在构造方法里，调用 <code>UUID.randomUUID()</code> 会产生一个随机唯一 ID 值</u></li>
</ul>
</li>
<li><u>使用默认的 <code>Date</code> 构造方法初始化 <code>DAte</code> 变量</u><ul>
<li><u>作为 <code>crime</code> 的默认发生时间，设置 <code>mDate</code> 变量值为当前日期</u></li>
</ul>
</li>
</ul>
<h1 id="7-4- 托管 UI-fragment"><a href="#7-4- 托管 UI-fragment" class="headerlink" title="7.4 托管 UI fragment"></a><u>7.4 托管 <code>UI fragment</code></u></h1><p><u> 为了托管 <code>UI fragment</code>，<code>activity</code> 必须：</u></p>
<ul>
<li><u>在其布局中为 <code>fragment</code> 的视图安排位置</u></li>
<li><u>管理 <code>fragment</code> 实例的生命周期</u></li>
</ul>
<h4 id="fragment 的生命周期"><a href="#fragment 的生命周期" class="headerlink" title="fragment 的生命周期"></a><u><code>fragment</code>的生命周期 </u></h4><p><u> 下图展示了 <code>fragment</code> 的生命周期：</u></p>
<p><u><img src="https://img.rosuh.me/wiki/wiki_2017_724ee3.png" alt="fragment 的生命周期图解"></u></p>
<ul>
<li><u><code>fragment</code>的生命周期类似于 <code>activity</code> 的生命周期，它具有停止、暂停以及运行状态，也拥有覆盖方法，用来在一些关键节点完成一些任务</u></li>
<li><u><code>fragment</code>生命周期和 <code>activity</code> 的方法的对应关系</u><ul>
<li><u>因为 <code>fragment</code> 代表 <code>activity</code> 工作，所以它的状态应该反映 <code>activity</code> 的状态</u></li>
</ul>
</li>
<li><u><code>fragment</code>生命周期与 <code>activity</code> 生命周期的一个关键不同在于：</u><ul>
<li><u><code>fragment</code>的生命周期方法由托管 <code>activity</code> 而不是操作系统调用的</u></li>
<li><u>操作系统不关心 <code>activity</code> 用来管理视图的 <code>fragment</code>；易言之，<code>fragment</code> 的使用是 <code>activity</code> 内部的事情</u></li>
</ul>
</li>
</ul>
<h4 id="托管的两种方式"><a href="# 托管的两种方式" class="headerlink" title="托管的两种方式"></a><u>托管的两种方式 </u></h4><p><u><code>activity</code> 托管 <code>UI fragment</code> 有如下两种方式：</u></p>
<ul>
<li><u>在 <code>activity</code> 布局中添加<code>fragment</code></u><ul>
<li><u>使用布局<code>fragment</code></u></li>
<li><u>简单但不灵活：在 <code>activity</code> 布局中添加 <code>fragment</code>，就等同于将<code>fragment</code> 及其视图与 <code>activity</code> 的视图绑定在一起，并且在 <code>activity</code> 的生命周期过程中，无法替换 <code>fragment</code> 视图</u></li>
</ul>
</li>
<li><u>在 <code>activity</code> 代码中添加<code>fragment</code></u><ul>
<li><u>比较复杂，但是也是唯一可以动态控制 <code>fragment</code> 的方式</u></li>
<li><u>何时添加 <code>fragment</code> 以及随后可以完成何种具体任务由你自己决定；也可以移除、替换和重新添加当前 <code>fragment</code> 等等</u></li>
</ul>
</li>
</ul>
<p><u>为了追求真正灵活的 UI 设计，就必须通过代码的方式添加<code>fragment</code>。</u></p>
<p><u>接下来我们将定义 <code>CrimeActivity</code> 的布局。</u></p>
<h4 id="定义容器布局"><a href="# 定义容器布局" class="headerlink" title="定义容器布局"></a><u>定义容器布局 </u></h4><p><u> 尽管我们选择的是在 <code>activity</code> 代码中添加 <code>UI fragment</code>，但是我们依旧<strong> 要在 <code>activity</code> 视图层级结构中为 <code>fragment</code> 视图安排位置</strong>。</u></p>
<p><u>在 <code>CrimeActivity</code> 的布局中，该位置就是下图所示的<code>FrameLayout</code>：</u></p>
<p><u><img src="https://img.rosuh.me/wiki/wiki_201712_d7c848.png" alt="CrimeActivity 类的 fragment 托管布局"></u></p>
<ul>
<li><u><code>FragmentLayout</code>是服务于 <code>CrimeFragment</code> 的容器视图</u><ul>
<li><u>此容器视图是个通用性视图，不单用于 <code>CrimeFragment</code> 类，你还可以用它托管其他的<code>fragment</code></u></li>
</ul>
</li>
</ul>
<p><u>我们会在 <code>activity_crime.xml</code> 文件中使用 <code>FragmentLayout</code> 作为默认布局：</u></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"https://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:id</span>=<span class="string">"@+id/fragment_container"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><u>当前的 <code>activity_crime.xml</code> 布局文件仅由一个服务于单个 <code>fragment</code> 的容器视图组成</u><ul>
<li><u>除了自身组件之外，托管 <code>activity</code> 布局还可定义多个容器视图</u></li>
</ul>
</li>
</ul>
<h1 id="7-5- 创建 UI-fragment"><a href="#7-5- 创建 UI-fragment" class="headerlink" title="7.5 创建 UI fragment"></a><u>7.5 创建 <code>UI fragment</code></u></h1><p><u> 创建 <code>UI fragment</code> 的步骤与创建 <code>activity</code> 的步骤相同：</u></p>
<ul>
<li><u>定义用户界面布局文件</u></li>
<li><u>创建 <code>fragment</code> 类并设置其视图为定义的布局</u></li>
<li><u>编写代码以实例化组件</u></li>
</ul>
<h4 id="定义 CrimeFragment 的布局"><a href="# 定义 CrimeFragment 的布局" class="headerlink" title="定义 CrimeFragment 的布局"></a><u>定义 <code>CrimeFragment</code> 的布局</u></h4><ul>
<li><u><code>CrimeFragment</code>视图用来显示包含在 <code>Crime</code> 类实例中的信息</u></li>
</ul>
<p><u>balabala…</u></p>
<h4 id="创建 CrimeFragment 类"><a href="# 创建 CrimeFragment 类" class="headerlink" title="创建 CrimeFragment 类"></a><u>创建 <code>CrimeFragment</code> 类</u></h4><ol>
<li><u>实现 <code>fragment</code> 生命周期方法</u></li>
</ol>
<p><u><code>CrimeFragment</code>类是与模型及视图对象交互的控制器，用于显示特定的 <code>cirme</code> 的明确信息。并在用户修改这些信息立即进行更新。</u></p>
<p><u>我们上一个例子中，<code>activity</code>通过其生命周期方法完成了大部分逻辑控制工作。在本个例子中，这些工作 <code>fragment</code> 的生命周期方法完成的。</u></p>
<p><u><em><code>CrimeFragment.java</code></em></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.support.v4.app.Fragment;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Crime mCrime;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mCrime = <span class="keyword">new</span> Crime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u><em>解析</em>：</u></p>
<ul>
<li><u><code>Fragment.onCreate(Bundle)</code>是公共方法，而 <code>Activity.onCreate(Bundle)</code> 是受保护方法</u><ul>
<li><u><code>Fragment.onCreate(Bundle)</code>方法及其他 <code>Fragment</code> 生命周期方法必须是公共方法，因为托管 <code>fragment</code> 的<code>activity</code>要调用它们</u></li>
</ul>
</li>
<li><u><code>Fragment</code>同样具有保存及获取状态的<code>bundle</code></u><ul>
<li><u>类似于使用 <code>Activity.onSaveInstanceState(Bundle)</code>，我们需要覆盖<code>Fragment.onSaveInstanceState(Bundle)</code> 来使用</u></li>
</ul>
</li>
<li><u><code>fragment</code>的视图不是在 <code>Fragment.onCreate(Bundle)</code> 中生成的，虽然我们在该方法中配置了 <code>fragment</code> 实例，但是创建和配置 <code>fragment</code> 视图是在另一个 <code>fragment</code> 生命周期方法完成的</u></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCrateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, </span></span></span><br><span class="line"><span class="function"><span class="params">                       Bundle savedInstanceState)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><u>该方法实例化 <code>fragment</code> 视图的布局，然后将实例化的 <code>View</code> 返回给托管的<code>activity</code></u><ul>
<li><u><code>LayoutInflater, ViewGroup</code>是必要参数，<code>Bundle</code>用来存储恢复数据，可供该方法从保存状态下重建视图</u></li>
</ul>
</li>
</ul>
<p><u>下面我们在 <code>CrimeFragment.java</code> 中，添加 <code>onCreateView</code> 方法的实现代码，从 <code>fragment_crime.xml</code> 布局中实例化返回布局。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Bundle saveInstanceState)</span> </span>&#123;</span><br><span class="line">        View v = inflater.inflate(R.layout.fragment_crime, container, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><u><em>解析</em>：</u></p>
<ul>
<li><u>在 <code>onCreateView(...)</code> 方法中，<code>fragment</code>的视图是直接通过调用 <code>LayoutInflater.inflate(...)</code> 方法并传入布局的资源 ID 生成的</u><ul>
<li><u>第二个参数是视图的父视图，我们通常需要父视图来正确配置组件</u></li>
<li><u>第三个参数告诉布局生成器是否将生成的视图添加个给父视图</u><ul>
<li><u>传入 <code>flase</code> 表示我们将以代码的方式添加视图</u></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><u>在 <code>fragment</code> 中实例化组件</u></li>
</ol>
<p><u><code>fragment</code>中的 <code>EditText, CheckBox, Button</code> 组件，也都是在 <code>onCreateView(...)</code> 方法里实例化的。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Bundle saveInstanceState)</span> </span>&#123;</span><br><span class="line">        View v = inflater.inflate(R.layout.fragment_crime, container, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        mTitleFiled = (EditText)v.findViewById(R.id.crime_title);</span><br><span class="line">        mTitleFiled.addTextChangedListener(<span class="keyword">new</span> TextWatcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// This space intentionally left blank</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">                mCrime.setTitle(s.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// This on too</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><u>对比 <code>Activity</code> 中实例化组件，<code>Fragment</code>中需要手动调用 <code>View.findViewById()</code> 方法</u></li>
<li><u><code>onTextChanged(..)</code>方法中，调用 <code>CharSequence</code>(表示用户输入) 的<code>toString()</code>方法</u><ul>
<li><u>该方法最后返回用来设置的 <code>Crime</code> 标题字符串</u></li>
</ul>
</li>
</ul>
<p><u>接下来设置 <code>Button</code> 组件，让他显示 <code>crime</code> 的发生日期。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  mDateButton = (Button)v.findViewById(R.id.crime_date);</span><br><span class="line">        mDateButton.setText(mCrime.getDate().toString());</span><br><span class="line">        mDateButton.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><u>此处只是显示日期，而点击功能没有启用。</u></p>
<p><u>接着设置 <code>ChcekBox</code> 组件。引用它并设置监听器，根据用户操作，更新 <code>mSolved</code> 状态。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  mSolvedCheckBox = (CheckBox)v.findViewById(R.id.crime_solved);</span><br><span class="line">        mSolvedCheckBox.setOnCheckedChangeListener(<span class="keyword">new</span> OnCheckedChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCheckedChanged</span><span class="params">(CompoundButton buttonView, <span class="keyword">boolean</span> isChecked)</span> </span>&#123;</span><br><span class="line">                mCrime.setSolved(isChecked);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="7-6- 向 FragmentManager 添加 UI-fragment"><a href="#7-6- 向 FragmentManager 添加 UI-fragment" class="headerlink" title="7.6 向 FragmentManager 添加 UI fragment"></a><u>7.6 向 <code>FragmentManager</code> 添加 <code>UI fragment</code></u></h1><p><u><code>fragment</code> 自己无法在屏幕上显示视图，我们需要把 <code>CrimeFragment</code> 添加给<code>CrimeActivity</code>。</u></p>
<ul>
<li><u><code>FragmentManager</code>类负责管理 <code>fragment</code> 并将它们的视图添加到 <code>activity</code> 的视图层级结构中</u><ul>
<li><u><code>Activity</code>类中添加了<code>FragmentManager</code></u></li>
</ul>
</li>
</ul>
<p><u><img src="http://img.rosuh.me/wiki/wiki_201712_720ea7.png" alt="FragmentManager 图解"></u></p>
<ul>
<li><u><code>FragmentManager</code>具体管理</u><ul>
<li><u><code>fragment</code>队列</u></li>
<li><u><code>fragment</code>事务回退栈</u></li>
</ul>
</li>
</ul>
<p><u>在本例中，我们只需关心 <code>FragmentManager</code> 管理的 <code>fragment</code> 队列。</u></p>
<ul>
<li><u>以代码的方式将 <code>fragment</code> 添加给 <code>activity</code>，需要直接调用<code>activity</code> 的<code>fragmentManager</code></u><ul>
<li><u>先获取 <code>fragmentManager</code> 本身</u></li>
<li><u>在 <code>CrimeActivity.java</code> 中，在 <code>onCreate(Bundle)</code> 方法中添加代码取得<code>fragmentManager</code></u></li>
</ul>
</li>
</ul>
<p><u><em>获取<code>fragmentManager</code>（<code>CrimeActivity.java</code>）</em></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_crime);</span><br><span class="line"></span><br><span class="line">        android.support.v4.app.FragmentManager fm = getSupportFragmentManager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fragment 事务"><a href="#fragment 事务" class="headerlink" title="fragment 事务"></a><u><code>fragment</code>事务 </u></h4><p><u> 获取 <code>fragmentManager</code> 后，再获取一个 <code>fragment</code> 交给它管理。</u></p>
<p><u><em>添加一个<code>CrimeFragment</code>（<code>CrimeActivity.java</code>）</em></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Fragment fragment = fm.findFragmentById(R.id.fragment_container);</span><br><span class="line"><span class="keyword">if</span> (fragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            fragment = <span class="keyword">new</span> CrimeFragment();</span><br><span class="line">            fm.beginTransaction()</span><br><span class="line">                    .add(R.id.fragment_container, fragment)</span><br><span class="line">                    .commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><u><code>new</code> –&gt; <code>add</code> –&gt; <code>commit</code></u><ul>
<li><u>事务的创建到提交的过程</u></li>
</ul>
</li>
<li><u><code>fragment</code>事务用来被添加、移除、附加、分离或替换 <code>fragment</code> 队列中的<code>fragment</code></u><ul>
<li><u>这是 <code>fragment</code> 动态组装和重新组装用户界面的关键</u></li>
</ul>
</li>
<li><u><code>Fragment.beginTransaction()</code></u><ul>
<li><u>创建并返回 <code>fragmentTransaction</code> 实例</u><ul>
<li><u>该实例类支持流接口（fluent interface）的链式方法调用，以此配置 <code>FragmentTransaction</code> 再返回它</u></li>
</ul>
</li>
</ul>
</li>
<li><u><code>add</code>是整个事务的核心</u><ul>
<li><u>参数</u><ul>
<li><u>容器视图资源 ID</u><ul>
<li><u>告诉 <code>FragmentManager</code>，<code>fragment</code> 视图应该出现在 <code>activity</code> 视图的什么位置</u></li>
<li><u>作为 <code>FragmentManager</code> 队列中 <code>fragment</code> 的唯一标志</u></li>
</ul>
</li>
<li><u>新创建的<code>CrimeFragment</code></u></li>
</ul>
</li>
</ul>
</li>
<li><u>从 <code>FragmentManager</code> 中获取<code>CrimeFragment</code>，使用容器视图资源 ID 就行了</u><ul>
<li><u>如果要向 <code>activity</code> 添加多个 <code>fragment</code>，通常就需要分别为每个<code>fragment</code> 创建具有不同 ID 的不同容器</u></li>
</ul>
</li>
</ul>
<p><u>总结起来，其是就是：</u></p>
<p><u><img src="http://img.rosuh.me/wiki/wiki_201712_04aff3.png" alt="总结"></u></p>
<h4 id="FragmentManafer 和 fragment 生命周期"><a href="#FragmentManafer 和 fragment 生命周期" class="headerlink" title="FragmentManafer 和 fragment 生命周期"></a><u><code>FragmentManafer</code>和 <code>fragment</code> 生命周期</u></h4><p><u><img src="http://img.rosuh.me/wiki/wiki_201712_5265c7.png" alt="再探 fragment 生命周期"></u></p>
<ul>
<li><u><code>activity</code>的 <code>FragmentManager</code> 负责调用队列中的 <code>fragment</code> 的生命周期方法</u><ul>
<li><u>添加 <code>fragment</code> 供<code>FragmentManager</code>管理时，<code>onAttach(Context), onCreate(Bundle)</code>和 <code>onCreateView(...)</code> 方法会被调用</u></li>
<li><u>托管 <code>activity</code> 的<code>onCreate(Bundle)</code>方法执行后，<code>onActivityCreated(Bundle)</code>方法也不会被调用</u><ul>
<li><u>因为 <code>CrimeActivity.onCreate(Bundle)</code> 方法中添加 <code>CrimeFragment</code>，所以<code>fragment</code> 被添加后，该方法会被调用</u></li>
</ul>
</li>
</ul>
</li>
<li><u>当 <code>activity</code> 处于运行状态时，添加 <code>fragment</code> 后</u><ul>
<li><u><code>FragmentManager</code>会立即驱赶（指让 <code>fragment</code> 走得快一点…）<code>fragment</code>，调用一系列必要的生命周期方法，快速赶上 <code>activity</code> 的步伐</u></li>
<li><u>一旦赶上，托管的 <code>activity</code> 的<code>FragmentManager</code>就会边接收操作系统的指令，边调用其他生命周期方法，让 <code>fragment</code> 与<code>activity</code>的状态保持一致</u></li>
</ul>
</li>
</ul>
<h1 id="7-7- 采用 fragment 应用架构"><a href="#7-7- 采用 fragment 应用架构" class="headerlink" title="7.7. 采用 fragment 应用架构"></a><u>7.7. 采用 <code>fragment</code> 应用架构 </u></h1><p><u> 尽管 <code>fragment</code> 组件可以复用，但是正确使用 <code>fragment</code> 非常重要 ，否则就边成了滥用。</u></p>
<ul>
<li><u><code>fragment</code>时用来封装关键组件以便复用</u><ul>
<li><u>关键组件：针对应用的整个屏幕来讲的</u></li>
<li><u>单屏使用大量的 <code>fragment</code>，不仅使代码充斥<code>fragment</code> 事务处理，模块的职责分工也会不清晰</u></li>
<li><u>如果由很多零碎的晓组件需要复用，比较好的架构设计时使用定制视图</u></li>
</ul>
</li>
<li>实践证明：<strong>应用单屏最多使用 2 ~ 3 个 <code>fragment</code></strong> </li>
</ul>
<p><u><img src="http://img.rosuh.me/wiki/wiki_201712_e4ee9d.png" alt="少就是多的哲学"></u></p>
<h4 id="使用 fragment 的理由"><a href="# 使用 fragment 的理由" class="headerlink" title="使用 fragment 的理由"></a><u>使用 <code>fragment</code> 的理由</u></h4><ul>
<li><u>实际开发中，尽管有时候可用可不用，但是我们还是会采用<code>fragment</code></u><ul>
<li><u>因为后期添加 <code>fragment</code> 是一个大坑</u></li>
</ul>
</li>
</ul>
<p>作者坚信的 AUF（Always Use Fragments），总是使用<code>fragment</code>。</p>
<h1 id="7-8- 深入学习：fragment 与支持库"><a href="#7-8- 深入学习：fragment 与支持库" class="headerlink" title="7.8 深入学习：fragment 与支持库"></a>7.8 深入学习：<code>fragment</code>与支持库</h1><ul>
<li><code>AppCompat</code>库没有实现 <code>fragment</code> 功能，它依赖于 <code>support-4</code> 库，是个后者实现了 <code>fragment</code> 功能</li>
<li><code>support-v4</code>实现了 <code>fragment</code> 功能<ul>
<li>其库内也有一个 <code>Activity</code> 子类：<code>FragmentActivity</code></li>
<li>而 <code>AppCompatActivity</code> 时<code>FragmentActivity</code>的子类，所以应用能使用支持库版本的<code>fragment</code></li>
</ul>
</li>
</ul>
<p><img src="http://img.rosuh.me/wiki/wiki_201712_b243e8.png" alt="AppCompatActivity 继承树"></p>
<h1 id="7-9- 深入学习：为什么优先使用支持库版本的 fragment"><a href="#7-9- 深入学习：为什么优先使用支持库版本的 fragment" class="headerlink" title="7.9 深入学习：为什么优先使用支持库版本的 fragment"></a>7.9 深入学习：为什么优先使用支持库版本的 <code>fragment</code></h1><h4 id="支持库版本的 fragment 使用起来最方便"><a href="# 支持库版本的 fragment 使用起来最方便" class="headerlink" title="支持库版本的 fragment 使用起来最方便"></a> 支持库版本的 <code>fragment</code> 使用起来最方便</h4><ul>
<li>Google 每年会多次更新支持库，并借此引入新特性、修复 bug<ul>
<li>支持库的本意是方便在不支持该 API 的旧版本上使用</li>
</ul>
</li>
<li>支持库版本的 <code>fragment</code> 没有显著的缺点<ul>
<li>功能实现上和系统内置的没有不同</li>
<li>唯一缺点是导入支持库包会占用额外空间</li>
</ul>
</li>
</ul>
<h4 id="如何使用内置版？"><a href="# 如何使用内置版？" class="headerlink" title="如何使用内置版？"></a>如何使用内置版？</h4><p>如果要使用内置版本的<code>fragment</code>，需要对项目作如下改动：</p>
<ul>
<li>弃用 <code>FragmentActivity</code> 类，改用标准库中的 <code>Activity</code> 类（<code>android.app.Activity</code>）</li>
<li>弃用 <code>android.support.v4.app.Fragment</code> 类，改用 <code>android.app.Fragment</code> 类</li>
<li>弃用 <code>getSupportFragmentManager()</code> 方法，改用 <code>getFragmentManager()</code> 方法获取<code>FragmentManager</code></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android 开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[4 第一个程序]]></title>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E8%83%BD/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/4-the-first-program/</url>
      <content type="html"><![CDATA[<h1 id="4-1- 一个源程序从写出到执行的过程"><a href="#4-1- 一个源程序从写出到执行的过程" class="headerlink" title="4.1 一个源程序从写出到执行的过程"></a>4.1 一个源程序从写出到执行的过程</h1><ol>
<li>编写汇编源程序<ul>
<li>产生一个存储源程序的文本文件</li>
</ul>
</li>
<li>对源程序进行编译链接<ul>
<li>使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件进行链接。生成可在操作系统中直接运行的可执行文件</li>
</ul>
</li>
</ol>
<ul>
<li>可执行文件包含两部分内容<ul>
<li>程序和数据<ul>
<li>程序：从源程序中的汇编指令翻译过来的机器码</li>
<li>数据：源程序中定义的数据</li>
</ul>
</li>
<li>相关的描述信息<ul>
<li>描述类似程序多大、占用多少内存空间等等</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>执行可执行文件中的程序<ul>
<li>操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如设置 CS:IP 指向第一条要执行的指令），容纳后由 CPU 执行程序</li>
</ul>
</li>
</ol>
<h1 id="4-2- 源程序"><a href="#4-2- 源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序 </h1><p> 下面时一段简单的汇编程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    mov ax, 0123H</span><br><span class="line">    mov bx, 0456H</span><br><span class="line">    add ax, bx</span><br><span class="line">    add ax, ax</span><br><span class="line"></span><br><span class="line">    mov ax, 4c00H</span><br><span class="line">    int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>程序说明</strong></p>
<h2 id="伪指令"><a href="# 伪指令" class="headerlink" title="伪指令"></a>伪指令 </h2><p> 在汇编程序中有两种指令：</p>
<ul>
<li>汇编指令<ul>
<li>对应机器码，被编译为机器指令，最终被 CPU 执行</li>
</ul>
</li>
<li>伪指令<ul>
<li>编译器执行伪指令。编译器将根据伪指令来进行相关的编译工作</li>
</ul>
</li>
</ul>
<p>在上面的例子中的伪指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XXX segment</span><br><span class="line">	:</span><br><span class="line">	:</span><br><span class="line">	:</span><br><span class="line">XXX ends</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>segment</code>和 <code>ends</code> 是成对使用的伪指令</p>
<ul>
<li><p>这是在写可被编译器编译的汇编程序时必须要用到的一对伪指令</p>
</li>
<li><p><code>segmnet</code>和 <code>ends</code> 的功能是定义一个段</p>
<ul>
<li><code>segment</code>说明一个段的开始</li>
<li><code>ends</code>说明一个段的结束</li>
</ul>
</li>
<li><p>使用格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line">	:</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><em>一个汇编程序由多个段组成，这些段被用来存放代码、数据或当作栈空间来使用</em></p>
<ul>
<li><code>end</code><ul>
<li>汇编程序的结束标记</li>
<li>如果程序写完了，就要在结尾处加上指令<code>end</code>，否则编译器无法知道程序在何处结束</li>
</ul>
</li>
<li><code>assume</code><ul>
<li>这条伪指令的含义为“假设”。他假设某一段寄存器和程序中的某一个 <code>segment...ends</code> 定义的段相关联，通过 <code>assume</code> 说明这种关联</li>
<li>在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系</li>
</ul>
</li>
</ul>
<p><em>在例子中，<code>code segment...codeseg ends</code>定义了一个名为 <code>codeseg</code> 的段，在这个段中存放代码，所以这个段是一个代码段。在程序的开头，用 <code>assume cs:codeseg</code> 将用作代码段的段 <code>codeseg</code> 和 CPU 中的段寄存器 <code>cs</code> 联系起来</em>。</p>
<h2 id="源程序中的“程序”"><a href="# 源程序中的“程序”" class="headerlink" title="源程序中的“程序”"></a>源程序中的“程序”</h2><p>用汇编语言写的源程序，包括伪指令和汇编指令：</p>
<ul>
<li>汇编指令组成了最终由计算机执行的程序</li>
<li>源程序中的伪指令由编译器执行</li>
</ul>
<p><strong>源程序汇总最终由计算机执行、处理的程序或数据，称为程序 </strong>。<strong> 程序最先以汇编指令的形式存在于源程序中，经过编译、链接后转变为机器码，存储在可执行文件中</strong>。</p>
<p><img src="https://img.rosuh.me/wiki/wiki_2017_f.png" alt="程序经编译链接后变为机器码"></p>
<h2 id="标号"><a href="# 标号" class="headerlink" title="标号"></a>标号</h2><ul>
<li>源程序中除了汇编指令和伪指令外，还有一些标号，比如<code>codeseg</code></li>
<li>一个标号指代了一个地址<ul>
<li><code>codeseg</code>在 <code>segment</code> 的前面，作为一个段的名称，这个段最终将被编译、链接程序处理为一个段的段地址</li>
</ul>
</li>
</ul>
<h2 id="程序的结构"><a href="# 程序的结构" class="headerlink" title="程序的结构"></a>程序的结构</h2><ol>
<li><p>定义一个程序段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">	:</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>在段中写入指令，实现任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">	mov ax, 2</span><br><span class="line">	add ax, ax</span><br><span class="line">	add ax, ax</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>指出程序在何时结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">	mov ax, 2</span><br><span class="line">	add ax, ax</span><br><span class="line">	add ax, ax</span><br><span class="line">abc ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>将程序段和寄存器联系起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">	mov ax, 2</span><br><span class="line">	add ax, ax</span><br><span class="line">	add ax, ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="程序返回"><a href="# 程序返回" class="headerlink" title="程序返回"></a>程序返回</h2><ul>
<li>当一个程序结束后，将 CPU 的控制权交还给是他得以运行的程序，这个过程就叫程序返回</li>
<li>在程序的末尾添加返回的程序段以实现程序返回</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure>
<h2 id="语法错误和逻辑错误"><a href="# 语法错误和逻辑错误" class="headerlink" title="语法错误和逻辑错误"></a>语法错误和逻辑错误</h2><h1 id="4-3- 编辑源程序"><a href="#4-3- 编辑源程序" class="headerlink" title="4.3 编辑源程序"></a>4.3 编辑源程序</h1><ul>
<li>可以使用 <code>Edit</code> 的方式编辑源程序</li>
<li>也可以使用其他类型文本编辑器，然后保存后缀为 <code>asm</code> 文件</li>
</ul>
<h1 id="4-4- 编译"><a href="#4-4- 编译" class="headerlink" title="4.4 编译"></a>4.4 编译</h1><ul>
<li><code>source.asm</code>–&gt;<code>target.obj</code><ul>
<li>源文件编译之后产生目标文件</li>
<li>中途可以选择生成 <strong> 列表文件</strong>，这个文件是编译器将源程序编译为目标文件的过程中产生的中间结果</li>
<li>中途还可以加入 <strong> 交叉引用文件</strong></li>
</ul>
</li>
<li>编译环境 <br> 编译的环境，从 windows 的 <code>masm</code>和 <code>ml</code> 到 Linux 的<code>fasm</code>，不一而足。不同的环境对编译伪指令的支持不一样，需要查阅文档。</li>
</ul>
<h1 id="4-5- 链接"><a href="#4-5- 链接" class="headerlink" title="4.5 链接"></a>4.5 链接</h1><ul>
<li><code>target.obj</code> –&gt; <em>Linked</em> –&gt; <code>execute.exe</code><ul>
<li>将目标文件链接之后产生可执行文件</li>
</ul>
</li>
<li>链接环境 <br>windows 下的<code>link.exe</code> 和<code>ml.exe</code></li>
<li>链接的作用是什么？<ul>
<li>如果源程序很大，可以将它分为多个源程序来编译，每个源程序编译成目标文件后，再用链接程序将它们链接到一起，生成一个可执行文件</li>
<li>程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件链接到一起，生成一个可执行文件</li>
<li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容不能直接用来生成可执行文件，链接程序将这些内容处理为最终的可执行信息</li>
</ul>
</li>
</ul>
<h1 id="4-6- 谁来执行可执行文件？"><a href="#4-6- 谁来执行可执行文件？" class="headerlink" title="4.6 谁来执行可执行文件？"></a>4.6 谁来执行可执行文件？</h1><ul>
<li>CPU 控制权<ul>
<li>在 DOS 中，可执行文件中的程序 <code>P1</code> 若要运行，必须由一个正在运行的程序 <code>P2</code>，将<code>P1</code> 从可执行文件中载入内存，将 CPU 的控制权交给它；当 <code>P1</code> 运行完毕后，<code>P1</code>将 CPU 控制权交还<code>P2</code></li>
</ul>
</li>
</ul>
<p>在上述程序中，将 <code>1.exe</code> 载入内存的，就是<code>shell</code>。</p>
<h3 id="操作系统的 -Shell"><a href="# 操作系统的 -Shell" class="headerlink" title="操作系统的 Shell"></a>操作系统的 Shell</h3><ul>
<li>任何通用的操作系统，都要提供一个 shell （外壳）程序，供操作人员使用这个程序来操作计算机</li>
<li>DOS 的 shell<ul>
<li>DOS 中有一个<code>command.com</code>，这个被称为命令解释器的东西就是 DOS 系统的 shell 了</li>
<li>DOS 启动完成初始化之后，就会运行<code>command.com</code></li>
<li><code>command.com</code>运行后，执行完其他任务之后，在屏幕上显示出当前盘符和路径组成的提示符，等待用户输入</li>
</ul>
</li>
</ul>
<h1 id="4-9- 程序执行过程的跟踪"><a href="#4-9- 程序执行过程的跟踪" class="headerlink" title="4.9 程序执行过程的跟踪"></a>4.9 程序执行过程的跟踪</h1><ul>
<li>为了查看程序运行过程的细节，以便跟踪错误，我们可以使用 <code>debug</code> 来查看单步执行的过程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug 1.exe</span><br></pre></td></tr></table></figure>
<p>进入 <code>debug</code> 环境后，就可以使用 <code>debug</code> 的指令来控制程序的运行了。</p>
<ul>
<li><code>r</code><ul>
<li><code>CX</code>寄存器表示当前程序的长度</li>
</ul>
</li>
</ul>
<h3 id="程序被藏在了哪里？"><a href="# 程序被藏在了哪里？" class="headerlink" title="程序被藏在了哪里？"></a>程序被藏在了哪里？</h3><ul>
<li><code>debug</code>会先找一个单元作为起止地址为<code>SA:0000</code>（即起止地址的偏移地址为 0）的容量足够的空闲内存区</li>
<li>在这段内存区的前 256 个字节中，创建一个称为程序段前缀（PSP）的数据区，DOS 要利用 PSP 来和被加载的程序进行通信</li>
<li>从这段内存区的 256 字节处开始（在 PSP 的后面），将程序装入，程序的地址被设为<code>SA+10H:0</code></li>
<li>将该段内存区的段地址存入 <code>ds</code> 中，初始化其他相关寄存器后，设置 <code>CS:IP</code> 指向程序的入口</li>
</ul>
<p><img src="https://img.rosuh.me/wiki/wiki_2017_7.png" alt="EXE 文件中程序的加载过程"></p>
<ul>
<li><code>int 21</code> 执行之后，程序显示出 <code>Program terminated normally</code> 返回到 <code>debug</code> 中，则表示程序正常结束了<ul>
<li>要使用 <code>P</code> 命令执行<code>int 21</code></li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 计算机技能 </category>
            
            <category> 汇编基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> assembly </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[5 [BX] 和 loop 指令]]></title>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E8%83%BD/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/5-BX-and-loop-instruction/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h1><h2 id="1-bx- 和内存单元的描述"><a href="#1-bx- 和内存单元的描述" class="headerlink" title="1. [bx] 和内存单元的描述"></a>1. <code>[bx]</code>和内存单元的描述</h2><ul>
<li>描述一个内存单元所需的两种信息<ul>
<li>内存单元的地址</li>
<li>内存单元的长度（类型）</li>
</ul>
</li>
</ul>
<p><code>[0]</code> 表示一个内存单元时， 0 表示单元的偏移地址，段地址默认在 <code>ds</code>寄存器中，单元的长度（类型）可以由具体指令中的其他操作对象（比如寄存器）指出。</p>
<ul>
<li><code>[bx]</code> 是一个内存单元的地址<ul>
<li>它的偏移地址存放在 <code>bx</code>中</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [bx]</span><br></pre></td></tr></table></figure>
<ul>
<li>表示将一个内存单元的内容送入 <code>ax</code>，这个内存单元的长度位 2 字节（字单元），存放一个字节，偏移地址在 <code>bx</code> 中 ，段地址在 <code>ds</code>中</li>
</ul>
<h2 id="2-loop"><a href="#2-loop" class="headerlink" title="2. loop"></a>2. <code>loop</code></h2><p>循环指令。</p>
<h2 id="3- 我们定义的描述性符号："><a href="#3- 我们定义的描述性符号：" class="headerlink" title="3. 我们定义的描述性符号：()"></a>3. 我们定义的描述性符号：<code>()</code></h2><p>为了描述上的简洁，在后续的学习中，我们将使用 <code>()</code> 来表示一个寄存器或一个内存单元中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(ax) ; 表示 ax 中的内容</span><br><span class="line">(al) ; 表示 al 中的内容</span><br></pre></td></tr></table></figure>
<h2 id="4- 约定符号 -idata 表示常量"><a href="#4- 约定符号 -idata 表示常量" class="headerlink" title="4. 约定符号 idata 表示常量"></a>4. 约定符号 <code>idata</code>表示常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [idata] ; 代表 mov ax,[1]、mov ax,[2]、或 mov ax,[3] 等</span><br><span class="line">mov bx, idata	; 代表 mov bx 1、mov bx, 2 或 mov bx, 3 等</span><br></pre></td></tr></table></figure>
<h1 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1 [BX]"></a>5.1 <code>[BX]</code></h1><p>2 个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [bx]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bx</code>中存放的数据作为一个偏移地址 <code>EA</code>，段地址<code>SA</code> 默认在 <code>ds</code> 中，将 <code>SA:EA</code> 处的数据送入 <code>ax</code> 中。即：<code>(ax) = ((ds)* 16 + (bx))</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [bx], ax</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bx</code>中存放的数据作为一个偏移地址 <code>EA</code>，段地址<code>SA</code> 默认在 <code>ds</code> 中，将 <code>ax</code> 中的数据送入内存 <code>SA:EA</code> 处。即：<code>((ds)*16 + (bx) = ax)</code></li>
</ul>
<h1 id="5-2-Loop 指令"><a href="#5-2-Loop 指令" class="headerlink" title="5.2 Loop 指令"></a>5.2 <code>Loop</code>指令</h1><ul>
<li><code>loop</code>指令的格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loop 标号</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>loop</code>被执行的过程</p>
<ul>
<li><code>(cx) = (cx) - 1</code></li>
<li>判断 <code>cx</code> 中的值，如果不为零则转至标号处执行程序，如果为零则向下执行</li>
<li><code>cx</code>中存放循环次数</li>
</ul>
</li>
</ul>
<h2 id="示例一"><a href="# 示例一" class="headerlink" title="示例一"></a>示例一</h2><ul>
<li>任务：编程计算 <code>2^2</code>，结果存放在<code>ax</code> 中</li>
<li>分析<ul>
<li>设 <code>(ax) = 2</code>，可计算<code>(ax) = (ax) * 2</code>，最后<code>(ax)</code> 中为 <code>2^2</code> 的值</li>
<li><code>N*2</code> 可用 <code>N+N</code> 实现</li>
</ul>
</li>
</ul>
<p>程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax, 2</span><br><span class="line">	add ax, ax</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="示例二"><a href="# 示例二" class="headerlink" title="示例二"></a>示例二</h2><ul>
<li>任务：计算 <code>2^3</code></li>
<li>分析：<ul>
<li><code>2^3 = 2*2*2</code>，若设 <code>(ax) = 2</code>，可计算<code>(ax) = (ax) * 2 * 2</code>，最后<code>(ax)</code> 中为 <code>2^3</code> 的值</li>
<li><code>N*2</code>可用 <code>N+N</code> 实现</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume  cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax, 2</span><br><span class="line">	add ax, ax</span><br><span class="line">	add ax, ax</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="示例三"><a href="# 示例三" class="headerlink" title="示例三"></a>示例三</h2><ul>
<li>任务：编程计算<code>2^12</code></li>
<li>分析<ul>
<li>类似之前的例子</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax, 2</span><br><span class="line">	; 作 11 次 add ax, ax</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>loop</code> 来简化我们的程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax, 2</span><br><span class="line">	mov cx, 11</span><br><span class="line">s: 	add ax, ax</span><br><span class="line">	loop s</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><em>分析</em>：</p>
<ul>
<li>标号<code>s</code><ul>
<li>这个标号标识了一个地址，这个地址处有一条指令<code>add ax, ax</code></li>
</ul>
</li>
<li><code>loop s</code><ul>
<li>CPU <strong>执行 <code>loop s</code> 的时候</strong>，要进行两步操作<ul>
<li><code>(cx) = (cx) - 1</code></li>
<li>判断 <code>cx</code> 中的值，不为 <code>0</code> 则转至标号 <code>s</code> 所标识的地址；如果为零则执行下一条</li>
</ul>
</li>
</ul>
</li>
<li>以下 3 条指令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	mov cx, 11</span><br><span class="line">s:  add ax, ax</span><br><span class="line">	loop s</span><br></pre></td></tr></table></figure>
<ul>
<li>执行 <code>loop s</code> 时，首先要将 <code>(cx)</code> 减 1，然后若 <code>(cx)</code> 不为 0，则向前转至 <code>s</code> 处执行<code>add ax, ax</code><ul>
<li>利用 <code>cx</code> 可以用来控制 <code>add ax,ax</code> 的执行次数</li>
</ul>
</li>
</ul>
<h1 id="5-3- 在 -Debug- 中跟踪用 loop 指令实现的循环程序"><a href="#5-3- 在 -Debug- 中跟踪用 loop 指令实现的循环程序" class="headerlink" title="5.3 在 Debug 中跟踪用 loop 指令实现的循环程序"></a>5.3 在 Debug 中跟踪用 <code>loop</code> 指令实现的循环程序</h1><ul>
<li>问题</li>
</ul>
<p>计算 <code>ffff:0006</code> 单元中的数乘以 3，结果存储在 <code>dx</code> 中。</p>
<ul>
<li>考虑三个事项<ul>
<li>运算后结果会否超出 <code>dx</code> 所能存储的范围？<ul>
<li><code>ffff:0006</code>单元中的数是一个字节型的数据，范围是 <code>0~255</code> 之间，则用它和 3 相乘结果不会大于 65535，可以在 <code>dx</code> 中存放下</li>
</ul>
</li>
<li>用循环累加来实现乘法，用哪个寄存器进行累加<ul>
<li>将 <code>ffff:0006</code> 单元中的赋值给 <code>ax</code>，用<code>dx</code> 进行累加。</li>
<li>先设<code>(dx) = 0</code>，然后作 3 次<code>(dx) = (dx)+(ax)</code></li>
</ul>
</li>
<li><code>ffff:0006</code>单元是一个字节单元，<code>ax</code>是一个 16 位寄存器，数据长度不一样，如何赋值？<ul>
<li>要想实现 <code>ffff:0006</code> 单元向 <code>ax</code> 赋值，应该令<code>(ah) = 0, (al) = (ffff6h)</code></li>
</ul>
</li>
</ul>
</li>
<li>代码实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax, 0ffffh</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov bx, 6		; 以上，设置 ds:bx 指向 ffff:6</span><br><span class="line">	</span><br><span class="line">	mov al, [bx]</span><br><span class="line">	mov ah, 0		; 以上，设置(al)=((ds*16)+(bx)), (ah)=0</span><br><span class="line">	</span><br><span class="line">	mov dx, 0		; 累计寄存器清 0</span><br><span class="line">	</span><br><span class="line">	mov cx, 3		; 循环 3 次 </span><br><span class="line">s:	add dx, ax</span><br><span class="line">	loop s			; 以上累加计算(ax)*3</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h			; 返回</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li>在汇编源程序中，数据不能以字母开头，所以要在前面加  0</li>
</ul>
<p>对上面的程序编译、链接之后，使用 <code>debug.exe</code> 对程序执行过程进行观察。</p>
<ul>
<li><code>u</code>查看被 <code>Debug</code> 加载入内存的程序可以看到 <code>loop s</code> 语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 源代码语句</span><br><span class="line">s:	add  dx, ax</span><br><span class="line">	loop s</span><br><span class="line"># 载入内存的语句</span><br><span class="line">0B3D:0012 ADD DX,AX</span><br><span class="line">0B3D:0014 LOOP, 0012</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>s</code> 已经被具体的地址所替代。</p>
<ul>
<li>访问内存地址时，<code>Debug</code>的显示方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0B44:0008 8A07	MOV AL,[BX]			DS:0006=35</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>debug</code> 右边出现了内存地址 <code>[bx]</code> 中的内容。根据我们设置的，段地址 <code>ds = ffff, bx=6</code>，所以我们可知道<code>ffff:6</code> 内存单元中的值为<code>35h</code>。</p>
<p>接着就是 <code>loop</code> 指令的执行，注意 <code>cx</code> 寄存器中的值，当该值等于 0 时，就跳出循环。</p>
<p>现在我们知道，修改 <code>cx</code> 寄存器中的内容可以间接实现乘法算术，对于在 <code>debug</code> 中的跟踪技巧而言，我们可以使用 <code>g</code> 指令，来快速执行到某一指令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g 0012</span><br></pre></td></tr></table></figure>
<p>这样就可以略过 <code>ds:0012</code> 之前的代码了。对于循环语句，就可以直接将地址改为循环后一句地址即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g 0016	# 假设循环语句地址为 0014</span><br></pre></td></tr></table></figure>
<p>此外，我们也可以使用 <code>p</code> 指令来自动执行循环。</p>
<p><em>遇到 <code>int 21h</code> 语句时应该使用 <code>p</code> 指令来正常结束程序哦。</em></p>
<h1 id="5-4-Debug 和汇编编译器 masm 对指令的不同处理"><a href="#5-4-Debug 和汇编编译器 masm 对指令的不同处理" class="headerlink" title="5.4 Debug 和汇编编译器 masm 对指令的不同处理"></a>5.4 <code>Debug</code>和汇编编译器 <code>masm</code> 对指令的不同处理</h1>]]></content>
      
        <categories>
            
            <category> 计算机技能 </category>
            
            <category> 汇编基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> assembly </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[4 积极的环境能改变人]]></title>
      <url>/%E8%BD%AF%E6%8A%80%E8%83%BD/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/4.0-positive-environment-can-change-person/</url>
      <content type="html"><![CDATA[<h3 id="改变"><a href="# 改变" class="headerlink" title="改变"></a>改变</h3><ul>
<li>传播真正有用的东西<ul>
<li>传播真实的知识</li>
<li>研究</li>
</ul>
</li>
<li>“精英民主化”<ul>
<li>学习优秀的，让全体都变得优秀</li>
</ul>
</li>
<li>“阻止改变的障碍”<ul>
<li>低估了自己带来变化的能力</li>
</ul>
</li>
<li>“改变如何发生”？<ul>
<li>改变可以呈几何级数扩散 &lt;–&gt; 理解人群中的指数效应 &lt;–&gt; 扩大影响力</li>
<li>“蝴蝶效应”</li>
<li>“六度分离现象”</li>
<li>“微笑效应”</li>
</ul>
</li>
<li>“凭外因无法令人幸福”<ul>
<li>剧烈的外界环境变化对幸福感的影响只持续一段时间，之后将会回到原来的水平</li>
<li>一旦满足基本需求之后，幸福感将不会再有很大提升</li>
<li>并不是说毫无变化，只是外界某一因素 剧烈变化，易会导致其他因素协同变化，人生会出现新的体验，会让你开心亦会让你伤心，所以幸福值又回到了原来水平<ul>
<li>社会制度影响除外，民主制度下的人们比独裁统治下的人们更幸福（可能是后者没有得到基本的满足</li>
</ul>
</li>
<li>“降低期望不能根本性提高幸福值”<ul>
<li>只能维持一段时间</li>
</ul>
</li>
</ul>
</li>
<li>“正确的期望才能获得幸福”<ul>
<li>感受幸福的意愿和可能性主要取决于 <strong> 我们的精神状态</strong><ul>
<li>而不是银行存款或其他</li>
</ul>
</li>
<li>关键在于：<ul>
<li>改变我们的观念和精神状态</li>
<li>在于改变我们看待这个世界的方式、看待成败的方式</li>
<li>在于我们选择去理解什么、去关注什么</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="人性"><a href="# 人性" class="headerlink" title="人性"></a>人性</h3><ul>
<li>人性是否应该受到限制？<ul>
<li>人性约束观：认为人性无法改变，他是恒定的。我们有特定的本能、偏好，他们是固定不变的；作为一个物种，与生俱来的；我们身上的缺点无法被改变<ul>
<li>除了放弃之外，可以选择对其进行引导；建立体制引导缺陷</li>
</ul>
</li>
<li>非人性约束观：认为人性可以不断进步；人性可以得到完善<ul>
<li>建立体制完善缺陷、改善缺陷</li>
</ul>
</li>
</ul>
</li>
<li>“成为平凡人”  – 人性约束观<ul>
<li>生活具有多样性，不是一直都是积极的</li>
<li>不要为了“积极”而积极，这样会付出极大的成本并且往往不遂人意</li>
<li>留给自己一个私人的空间，在这个房间里做一个凡人</li>
<li>“动机悖论”：善于接受自己的情绪，不要过度压抑</li>
</ul>
</li>
<li>情感、行为和认知<ul>
<li>情感 &lt;–&gt; 情绪：情绪没有正邪之分；糟糕的情绪亦是人的本性<ul>
<li>问题在于：<strong>我用什么态度对待和表达情绪</strong>？ </li>
</ul>
</li>
<li>行为：表达情绪的方式<ul>
<li>这个问题就涉及到道德领域，即有好坏之分；我们可以选择道德或不道德的方式对待其他人</li>
</ul>
</li>
<li>认知：改变自己对糟糕情绪的看法<ul>
<li>真诚地面对好坏情绪</li>
</ul>
</li>
</ul>
</li>
<li>“主动接受”<ul>
<li>识别好坏的能力</li>
</ul>
</li>
<li>冥想<ul>
<li>静坐</li>
<li>注意了转移到呼吸</li>
<li>深呼吸</li>
<li>思考世界和我们的联系、纽带</li>
<li>深呼吸</li>
<li>注意力转移到情绪上，接受你的情绪改变，让你的情绪随呼吸流出</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软技能 </category>
            
            <category> 积极心理学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哈佛幸福课 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 幸福 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1 信息、变形和课程简介]]></title>
      <url>/%E8%BD%AF%E6%8A%80%E8%83%BD/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/1.0-Information-transforation-and-introduction/</url>
      <content type="html"><![CDATA[<h1 id="01- 信息、变形与课程简介"><a href="#01- 信息、变形与课程简介" class="headerlink" title="01 信息、变形与课程简介"></a>01 信息、变形与课程简介</h1><p><em>2017-8-1 11:36:36</em> </p>
<ul>
<li>授课对象：对积极心理学有兴趣或者想要变得更开心的人<ul>
<li>不需要为了弄清楚某个概念而殚精竭虑，只需要把你觉得对你有用的知识应用到你的生活中</li>
</ul>
</li>
</ul>
<ul>
<li>关注点<ul>
<li>信息本身而不是信息的传递者</li>
</ul>
</li>
<li>以往“自助运动”的鄙陋<ul>
<li>语言上的巨人和行动上的矮子（over-promising and under-delivering）</li>
</ul>
</li>
<li>两个阶段<ul>
<li>学术阶段</li>
<li>应用阶段：我如何将这些东西应用到生活中</li>
</ul>
</li>
<li>积极心理学<ul>
<li>解释：<a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E6%9C%AC%E4%B8%BB%E4%B9%89%E5%BF%83%E7%90%86%E5%AD%A6" target="_blank" rel="external">人本主义心理学 </a> 的产物和衍生 </li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E6%9C%AC%E4%B8%BB%E7%BE%A9" target="_blank" rel="external">人本主义 </a> 和其他学派最大的不同是特别强调人的正面本质和价值，而并非集中研究人的问题行为，并强调人的成长和发展，称为 <a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%88%91%E5%AF%A6%E7%8F%BE" target="_blank" rel="external"> 自我实现</a>。 – Wiki</p>
</blockquote>
<ul>
<li>本课程传授的两个重要知识：信息（information）和变形（transformation）<ul>
<li><strong>什么是信息</strong><ul>
<li>人就像一个容器，接受外界的信息，直到填满整个容器</li>
<li>信息并不能提高人的生存、生活质量</li>
<li>信息是客观的，是多面的</li>
</ul>
</li>
<li><strong>什么是变形</strong><ul>
<li>改变容器的形状</li>
<li>让信息为我所用</li>
</ul>
</li>
<li><strong>利用信息</strong><ul>
<li>如何解读信息？如何理解以及关注点？</li>
<li>不止要获取信息，更要挖掘我们自己的潜能</li>
</ul>
</li>
<li><strong>挖掘潜能</strong><ul>
<li>“减法比加法更能让人的灵魂成长”</li>
<li>“凿去”无用的、功利主义的、浮躁的等等人性弊端</li>
</ul>
</li>
<li><strong>两面性</strong><ul>
<li>美好的生活包含成功和失败，或者说是失败之后奋斗的快感</li>
</ul>
</li>
<li><strong>本课程的其中一个目的</strong>：让常识更为人所知</li>
<li><strong>本课程的最终内容</strong>：让你成为最好的你</li>
</ul>
</li>
<li>保持向上的生活态度，自信并且保持提问</li>
</ul>
<hr>
<p><em>2017-8-1_第一节课</em></p>
<p>看了想睡觉…</p>
<p>看第一遍的时候没觉得主讲讲了那么多“话”，直到第二遍开始做笔记的时候才发现他有许多重复的观点的地方，可能是为了举多个例子解释吧。</p>
<p>毕竟第一节课，内容实质性不是很强，大多是介绍内容。</p>
<p>上述笔记多是基于快速跳跃而做的笔记，没有一秒一秒地过，难免有一些缺漏。</p>
]]></content>
      
        <categories>
            
            <category> 软技能 </category>
            
            <category> 积极心理学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哈佛幸福课 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 幸福 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[11 习惯]]></title>
      <url>/%E8%BD%AF%E6%8A%80%E8%83%BD/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/11-habit/</url>
      <content type="html"><![CDATA[<h2 id="自制力和成功"><a href="# 自制力和成功" class="headerlink" title="自制力和成功"></a>自制力和成功</h2><ul>
<li>自制力大小和成功没有必然联系<ul>
<li>大部分人的自制力都是固定的，不会发生改变的</li>
<li>仅有自制力比用不足以获得成功、获得改变或获得幸福</li>
<li>“自制力有限假说” &lt;–&gt; <em>罗伊·鲍迈斯特(Roy Baumeister) 研究</em> </li>
</ul>
</li>
</ul>
<h2 id="习惯成自然"><a href="# 习惯成自然" class="headerlink" title="习惯成自然"></a>习惯成自然</h2><blockquote>
<p>养成习惯需要定义严谨的行为模式，还要在特定的时间付诸行动、需要以深深扎根的价值观为驱动力 – 托尼·施瓦茨 (Tony Schwartz) 和吉姆·勒尔(Jim Loehr) </p>
</blockquote>
<ul>
<li>成功离不开孜孜不倦的训练和学习<ul>
<li>自制力有限所以并非全然依靠自制力去学习或行动</li>
<li>养成习惯之后更容易进行训练和学习 &lt;–&gt; 海明威和达芬奇</li>
</ul>
</li>
</ul>
<ul>
<li>将行为养成习惯之后，付出的自制力将大幅降低甚至为 0 <ul>
<li>早上起床刷牙</li>
<li>运动员长年累月的训练</li>
</ul>
</li>
<li>养成习惯需要足够的自制力<ul>
<li>不要尝试在一段时间内养成多个习惯，因为自制力是有限的，这样更容易导致全盘皆输</li>
<li>​</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软技能 </category>
            
            <category> 积极心理学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哈佛幸福课 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 幸福 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2 为什么要学习积极心理学]]></title>
      <url>/%E8%BD%AF%E6%8A%80%E8%83%BD/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/2.0-The-reason-of-learning-positive-psychology/</url>
      <content type="html"><![CDATA[<p><em>2017-8-2 09:28:38</em></p>
<ul>
<li> 心理学研究的领域的选择，是人类社会心理趋势或关注驱使的一种反映 <ul>
<li>1967 ~ 2000，消极心理学和积极心理学研究比例将近 21:1 </li>
</ul>
</li>
<li> 为什么要学习积极心理学？<ul>
<li> 研究有效的方法（积极心理学）至关重要：有效的方法对现实具有能动作用 <ul>
<li> 如果我们研究的方法在研究时有效，很大概率上这个方法在日常生活中会更有效 </li>
</ul>
</li>
<li> 快乐并不只是对痛苦的否定 </li>
<li> 研究如何培养积极心态是预防焦虑、抑郁等疑难问题最有效的方法 </li>
</ul>
</li>
</ul>
<ul>
<li> 如何研究出有效的方法？（如何探究积极心理学？<ul>
<li> 解决方法就在问题本身：特定问题创造特定现实 </li>
<li> 我们会因为事先的一个问题，然后预设立场；导致在观测客观现实的时候忽略于该问题“无关”的其他东西 <ul>
<li> 比如，夫妻之前总是提问“该如何改善关系”，就会陷入过度放大关系中的缺点而忽略更多的感情的险境中 </li>
<li>“吾日三省吾身” –&gt; 避免过度关注缺点 </li>
</ul>
</li>
<li> 我们应该在关注缺点、消极状态的同时，多关注优点、积极心理 </li>
</ul>
</li>
<li> 改善眼界 <ul>
<li> 关注优点、设立目标 –&gt; 内心理想主义 </li>
<li> 注意现实、立刻行动 –&gt; 客观现实主义 </li>
</ul>
</li>
<li> 利人利己的上升螺旋 <ul>
<li> 承认需要（承认弱点）</li>
<li> 接受帮助并帮助他人 </li>
<li> 善于选择优良的社会帮助 </li>
</ul>
</li>
<li> 适应力 <ul>
<li> 含义：在复杂、难堪、困难的环境下仍然保持乐观的态度和实干的精神 </li>
<li> 养成：<ul>
<li> 一个榜样 </li>
<li>“我们要好好树立自己的信念”<ul>
<li>“我相信你” “你能做好” “你能成功” “你要自己承担生活的责任”</li>
<li>“别再埋怨”“别再埋怨社会、老师、父母”</li>
</ul>
</li>
<li> 将目光放在长处和优点上并加以培养 </li>
<li> 自我激励 </li>
</ul>
</li>
<li>“如何让自己的大学时光变得更加有意义？”<ul>
<li> 你要为这段时光负起责任 </li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软技能 </category>
            
            <category> 积极心理学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哈佛幸福课 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 幸福 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[5 信念是自我实现的预言]]></title>
      <url>/%E8%BD%AF%E6%8A%80%E8%83%BD/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/5.0-Faith-is-the-realistic-predictions/</url>
      <content type="html"><![CDATA[<h2 id="追求幸福"><a href="# 追求幸福" class="headerlink" title="追求幸福"></a>追求幸福 </h2><p><strong> 幸福之作用：</strong> </p>
<ul>
<li>幸福让人感觉很好<ul>
<li>幸福就是幸福</li>
</ul>
</li>
<li>幸福对我们的生活、我们的人际关系也产生了积极的影响<ul>
<li>开拓思路，帮助我们和其他人建立联系，提示自身潜力</li>
</ul>
</li>
<li>“积极情绪的扩展建设理论”<ul>
<li>积极情绪似乎会扩展人们暂时的想法，充实行动的库存并建立持久的个人资源</li>
<li>“通过体验积极情绪，人们变得更加富有创造力、更加博学多才、更有韧性、更具社交能力以及更加健康向上”</li>
</ul>
</li>
<li>“积极情绪帮助我们客服消极情绪”<ul>
<li>当我们被负面情绪所困时，我们的思考变得狭隘和压抑；我们的注意力仅停滞在事情本身</li>
</ul>
</li>
</ul>
<h4 id="情绪转换"><a href="# 情绪转换" class="headerlink" title="情绪转换"></a>情绪转换</h4><ul>
<li>糟糕情绪的 “N &amp; C” 循环<ul>
<li>Narrow and Constrict &lt;–&gt; 遭受痛苦</li>
</ul>
</li>
<li>积极情绪的 “B &amp; B” 循环<ul>
<li>Broaden and Build &lt;–&gt; 积极情绪 &lt;–&gt; 扩展思路和视野</li>
<li>来源可能是一部喜剧电影、一次深呼吸、一次与朋友间的互动</li>
</ul>
</li>
<li>挑战在于：如何将积极情绪和“允许自己成为普通人”的想法结合起来，去体会情绪，转移情绪；不再不如恶性循环之中</li>
</ul>
<h4 id="解决问题而非逃避问题"><a href="# 解决问题而非逃避问题" class="headerlink" title="解决问题而非逃避问题"></a>解决问题而非逃避问题</h4><ul>
<li>接受自己的糟糕的情绪</li>
<li>选择一种方式转换为积极情绪</li>
</ul>
<p>这样的过程会提高我们对情绪的调控能力，进而提高我们对糟糕情绪的免疫力；使我们的思路更加清晰和开阔。</p>
<h4 id="追求自我的幸福是自私的行为吗？"><a href="# 追求自我的幸福是自私的行为吗？" class="headerlink" title="追求自我的幸福是自私的行为吗？"></a>追求自我的幸福是自私的行为吗？</h4><ul>
<li>幸福是一个正和博弈<ul>
<li>幸福会传染，助人亦助己</li>
</ul>
</li>
<li>自私 ≠ 不道德</li>
</ul>
<h5 id="传播幸福最好的方式就是经营好自己的幸福"><a href="# 传播幸福最好的方式就是经营好自己的幸福" class="headerlink" title="传播幸福最好的方式就是经营好自己的幸福"></a>传播幸福最好的方式就是经营好自己的幸福 </h5><h2 id="信念是自我实现的预言"><a href="# 信念是自我实现的预言" class="headerlink" title="信念是自我实现的预言"></a> 信念是自我实现的预言</h2><ul>
<li>信念常常决定我们的行为、决定我们表现的优劣<ul>
<li>它是我们成功和幸福最精准的预测</li>
</ul>
</li>
<li>“期待效应”<ul>
<li>“皮格马利翁”实验</li>
</ul>
</li>
<li>“积极情景创造积极效应”<ul>
<li>“阿希从众实验”</li>
<li>“菲利普津巴多监狱实验”</li>
<li>“艾伦·蓝格实验”</li>
<li>巴吉（Barge）研究</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软技能 </category>
            
            <category> 积极心理学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哈佛幸福课 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 幸福 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[3 如何避免惬意的麻木]]></title>
      <url>/%E8%BD%AF%E6%8A%80%E8%83%BD/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/3.0-how-can-we-get-beyond-the-comfortably-nomb/</url>
      <content type="html"><![CDATA[<ul>
<li>惬意的麻木(Confortably numb)</li>
<li>积极心理学主要关注的是健康模式（health model） <ul>
<li>Saluto-genesis</li>
<li>生理、身体和心理的健康之源在哪？</li>
</ul>
</li>
<li>健康模式下不同层面的解决方式<ul>
<li>缺陷：我们只关注自身的不足</li>
<li>改善：应该给予优点同样程度的关注，将成功和愉悦联系在一起</li>
<li>问题：我们到底擅长什么？如何充分改进？我们的自然倾向是什么？我们将如何度过我们的一生？</li>
<li>行动：认清兴趣、培养优势以及追求激情<ul>
<li>问问自己：生活的意义是什么？我的人生目标是什么？我为什么在这里？我毕业之后想做什么？</li>
</ul>
</li>
<li>培养积极心理（乐观、目的性、意义等）等同于增强心理免疫能</li>
</ul>
</li>
</ul>
<h3 id="积极心理学的基础（本课程的前提"><a href="# 积极心理学的基础（本课程的前提" class="headerlink" title="积极心理学的基础（本课程的前提"></a>积极心理学的基础（本课程的前提</h3><ul>
<li>搭建桥梁：不同学科、学术和社会等</li>
<li>幸福与否不知取决于外界因素，更多的是个人理解和感受世界的能力</li>
<li>承认人性的缺漏还是从心理层面完善他？</li>
<li>幸福是并且应当是我们的最终追求和道德追求</li>
</ul>
<h4 id="桥梁"><a href="# 桥梁" class="headerlink" title="桥梁"></a>桥梁</h4><ul>
<li>世界需要 <strong> 具有实践精神的理想主义者</strong>(practical idealists)<ul>
<li>相信改变是会发生的</li>
</ul>
</li>
<li>理论和实践之间有很多代沟<ul>
<li>教师和学生：马福·科林斯计划，皮革马利温效应</li>
<li>如何赞扬别人和提高自信？如何培训自我效能？</li>
<li>瑜伽能减少入狱人员的重新犯罪几率</li>
<li>冥想可以改变大脑，提高人对消极情绪的抵抗能力</li>
<li>每周进行 3 次 /30min 以上的运动与现最有效的心理药物效果是一样的</li>
<li>解决矛盾的方法不只是创造接触（双方见面交流），更要创建一个只有双方努力才能达到的目标</li>
</ul>
</li>
<li>考虑实际，消除象牙塔和社会之间的隔阂<ul>
<li>作为学生要承担起上述责任</li>
</ul>
</li>
<li>“生长锥统计学”<ul>
<li>研究一般情况有助于观察当下，但无助于改善当下</li>
<li>研究基因演变最激烈的地方，这样我们可以知道最可能发生的可能</li>
<li>心理学上的作为“普通”，实际上是“平均精神状态”<ul>
<li>这一概念会导致全体精神状态下降</li>
</ul>
</li>
<li>与“精英主义”的区别<ul>
<li>研究最优秀的人同时也研究普通的人</li>
<li>研究最优秀的人对所有人是有益的</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软技能 </category>
            
            <category> 积极心理学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哈佛幸福课 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 幸福 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[6 乐观]]></title>
      <url>/%E8%BD%AF%E6%8A%80%E8%83%BD/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/6.0-positive/</url>
      <content type="html"><![CDATA[<h2 id="如何创建积极的环境"><a href="# 如何创建积极的环境" class="headerlink" title="如何创建积极的环境"></a>如何创建积极的环境 </h2><p><strong> 相信改变会发生，相信即便微小的难以记住的东西也会对心理产生极大的暗示</strong>。</p>
<ul>
<li>欣赏你爱的人的图片</li>
<li>欣赏美好的事物</li>
<li>在目力所及的地方放上令你感觉温暖、能让你感受到爱和友善的东西</li>
<li>名人名言</li>
<li>音乐、电影</li>
</ul>
<h2 id="自我效能的力量"><a href="# 自我效能的力量" class="headerlink" title="自我效能的力量"></a>自我效能的力量</h2><ul>
<li>“思考只是成功定律的一部分”<ul>
<li>成功离不开自我效能、艰苦奋斗和不断的失败</li>
</ul>
</li>
<li>“自我效能决定命运”<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%88%91%E6%95%88%E8%83%BD" target="_blank" rel="external">自我效能</a>：用于衡量个体本身对完成任务和达成目标能力的信念的程度或强度</li>
<li>“安慰剂效应”</li>
</ul>
</li>
</ul>
<h2 id="如何平衡期许和现实"><a href="# 如何平衡期许和现实" class="headerlink" title="如何平衡期许和现实"></a>如何平衡期许和现实 </h2><h3 id="两种调节机制"><a href="# 两种调节机制" class="headerlink" title="两种调节机制"></a> 两种调节机制</h3><ul>
<li>动力（motivation）：<ul>
<li>如果相信在某方面能做得更好，你更有可能做得更好</li>
</ul>
</li>
<li>统一性（consistency）<ul>
<li>人们会对世界产生 <a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%88%91%E5%9B%BE%E5%BC%8F" target="_blank" rel="external"> 心理图式</a><ul>
<li><strong>自我图式 </strong>（self-schema）是指一个长期及稳定的<a href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6" target="_blank" rel="external"> 记忆 </a>，内容是有关在特定行为领域下的<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%BF%B5" target="_blank" rel="external"> 信念 </a>、<a href="https://zh.wikipedia.org/wiki/%E7%B6%93%E9%A9%97" target="_blank" rel="external"> 经验 </a> 及对 <a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%88%91" target="_blank" rel="external"> 自我 </a> 的总括；也作“过去知识和经验的表征形式”</li>
<li>比如我们“知道”，如果把东西留着半空中，这个东西“就会掉下来”</li>
<li>比如“主观印象”</li>
</ul>
</li>
<li>心理图式对应的“客观世界”<ul>
<li>比如，留在半空中的东西确实掉下去了，是为客观事实</li>
</ul>
</li>
<li><strong>大脑不善于接受现实和理想之间的差距</strong><ul>
<li><strong>甚至会逃避、忽视这样的差距</strong></li>
</ul>
</li>
<li>为了让两者保持统一，要么 <strong> 改变客观事实 </strong>，<strong> 要么改变自己的想法</strong></li>
</ul>
</li>
</ul>
<h3 id="修复现实和理想的裂痕"><a href="# 修复现实和理想的裂痕" class="headerlink" title="修复现实和理想的裂痕"></a>修复现实和理想的裂痕</h3><ol>
<li>更新我们的主观想法</li>
<li>屏蔽客观信息</li>
<li>主动证实信息</li>
<li>创造一个新的现实 </li>
</ol>
<p>我们经常使用的是第二和第三种方法，因为我们不愿意“更新”我们的最初的想法，所以一旦发生了不符合我们预期的事情，我们会选择性忽略（不更新，屏蔽客观信息），然后去寻找支持我们原来想法的证据（主动证实信息）。</p>
<p>比如，我们以前认为小明是坏人。而小明最近几天一直在做好事，有很多人不善于接受新的改变，而持有一种观点“小明以前做过什么坏事”，然后去证实这件事。</p>
<p>也即是“问题创造现实”。这样的情况可以被避免。只要我们 <strong> 不要忽略掉积极的事情，并且小心求证消极的事情</strong>。</p>
<ul>
<li>客观现实的主观解释<ul>
<li>失败 –&gt; 成功证明某事不成功</li>
<li>成功 –&gt; 成功</li>
</ul>
</li>
<li>信念的功用<ul>
<li>“我相信” –&gt; “我会更努力工作” √</li>
<li>“我相信” –&gt; “会成功” ×</li>
<li>简言之：信念是为了更好地工作</li>
</ul>
</li>
<li>“失败和成功的次数一样多”<ul>
<li>迪安·西蒙顿（Dean Simonton）的研究：历史上最成功的科学家和艺术家也同样是那些失败最多次的</li>
<li>注意逻辑关系！失败最多次并不代表就会变成最成功的</li>
</ul>
</li>
<li>失败的功用<ul>
<li>成功需要行动 –&gt; 行动会产生失败 –&gt; 失败是不可避免的</li>
<li>不断从失败中汲取经验</li>
</ul>
</li>
</ul>
<h2 id="目标设立"><a href="# 目标设立" class="headerlink" title="目标设立"></a>目标设立 </h2><h3 id="积极和悲观主义者的区别"><a href="# 积极和悲观主义者的区别" class="headerlink" title="积极和悲观主义者的区别"></a> 积极和悲观主义者的区别</h3><ul>
<li>悲观主义者：无论长期或是短期，其设立的目标都很现实<ul>
<li>期望值不高, 信念不强 –&gt; 可能做得不好 &lt;-(思维一致性)-&gt; 调低目标难度<ul>
<li><strong>表现平平</strong>：“我早就说过我做不好” &lt;–&gt; “是的，你早就说过了，你真实在”</li>
<li><strong>表现优秀</strong>：“我这次可能是瞎猫碰上死耗子”“用尽了我一生的运气”</li>
</ul>
</li>
</ul>
</li>
<li>乐观主义者：短期目标 <strong> 天马行空</strong>，长期目标比较现实<ul>
<li>期望值高，动力十足 –&gt; 我能做得很好 &lt;–(思维一致性)–&gt; 调高目标难度<ul>
<li>表现平平：“我能从中学到什么？”“这是一次机会” &lt;–&gt; “为什么你就不能实际一点呢？稍微和 xx 学习一下吧” &lt;–&gt; 保持高度积极和高动力，不断努力直到把不可能化为可能</li>
</ul>
</li>
</ul>
</li>
<li>解释客观现实<ul>
<li>悲观主义者：将负面情况看成普遍现象<ul>
<li>“这一次没有成功，我不可能成功”“我就是这样的人”</li>
<li>“要么行，要么不行”</li>
</ul>
</li>
<li>乐观主义者：现实可以被学习并改变<ul>
<li>“我可以从中学到什么？”</li>
<li>“这是一次机会”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="心理健康与生理健康"><a href="# 心理健康与生理健康" class="headerlink" title="心理健康与生理健康"></a>心理健康与生理健康</h3><ul>
<li>客观事实解释角度会影响人体的免疫系统和复原力水平</li>
</ul>
<h2 id="乐观的等级"><a href="# 乐观的等级" class="headerlink" title="乐观的等级"></a>乐观的等级 </h2><p><strong> 如何分辨现实与非现实？</strong></p>
<ul>
<li>斯托克代尔悖论（Stockdale Paradox）：不要把最终胜利的信念和现实的磨练这个两个因素混淆起来，其中前者 <strong> 必不可少</strong>，而后者无论如何都要接受</li>
</ul>
<h3 id="成功：乐观、激情和勤奋"><a href="# 成功：乐观、激情和勤奋" class="headerlink" title="成功：乐观、激情和勤奋"></a>成功：乐观、激情和勤奋</h3><ul>
<li>乐观：相信自己能成功</li>
<li>激情：对所做事业充满激情</li>
<li>勤奋：努力地工作 –&gt; “勤奋没有替代品”</li>
</ul>
<h3 id="高期望和失望？"><a href="# 高期望和失望？" class="headerlink" title="高期望和失望？"></a>高期望和失望？</h3><ul>
<li>为什么人不互相鼓励追求高的目标？<ul>
<li>害怕伤及我们的自尊 &lt;–&gt; “期望和现实的比值为幸福值” &lt;–&gt; 期望低，幸福值高 （×）</li>
</ul>
</li>
<li><strong>幸福有自己的稳态</strong><ul>
<li>“现实不如期望” &lt;–&gt; 幸福感降低 (√) &lt;–(<strong> 一段时间</strong>)–&gt; 幸福感恢复（√）</li>
<li>“现实优于期望” &lt;–&gt; 幸福感升高 (√) &lt;–(<strong> 一段时间</strong>)–&gt; 幸福感恢复（√）</li>
</ul>
</li>
<li>“稳态的缺点”<ul>
<li>幸福感是固定的吗？是由我的基因决定的吗？我无法一直提升我的幸福感吗？</li>
</ul>
</li>
</ul>
<h3 id="提升你的基础幸福感：解决问题而不是逃避问题"><a href="# 提升你的基础幸福感：解决问题而不是逃避问题" class="headerlink" title="提升你的基础幸福感：解决问题而不是逃避问题"></a>提升你的基础幸福感：解决问题而不是逃避问题</h3><ul>
<li>解决问题：允许自己冒险，处于“学习区”中，承担失败的风险；处理、解决以及直面你的问题</li>
<li>依据？<ul>
<li>自我认知：“我们使用同一种方法来判断自己和他人”<ul>
<li>你不敢做的事，不敢尝试的事情，往往会给与之高的评价，一旦自己做了，也会给自己高度评价</li>
<li>比如，发表演讲、争取权利等等</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软技能 </category>
            
            <category> 积极心理学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哈佛幸福课 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 幸福 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[7 逆境和机遇]]></title>
      <url>/%E8%BD%AF%E6%8A%80%E8%83%BD/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/7.0-adversity-or-chance/</url>
      <content type="html"><![CDATA[<h2 id="如何变得更加乐观"><a href="# 如何变得更加乐观" class="headerlink" title="如何变得更加乐观"></a>如何变得更加乐观 </h2><h3 id="1- 付诸行动"><a href="#1- 付诸行动" class="headerlink" title="1. 付诸行动"></a>1. 付诸行动</h3><p><em> 基于 艾伯特·班杜拉(Albert Bandura) 的研究</em></p>
<ul>
<li>不顾事实的夸奖会对目标产生伤害<ul>
<li>诸如早上起床对镜子里的自己说十句赞美自己的话之类的</li>
</ul>
</li>
<li>一味夸奖不如 <strong> 付诸行动</strong><ul>
<li><strong>努力和解决问题是通向成功的唯一途径</strong>：通过努力和实践会取得更大的成功</li>
<li>“让人看到自己的努力，看到自己步入正轨”</li>
<li>苏林·祁克果(Soren Kierkegarrd) –&gt; “敢于尝试只会暂时失去立足处，不敢尝试将失去自我”</li>
</ul>
</li>
</ul>
<h3 id="2- 想象：把目标呈现在心中"><a href="#2- 想象：把目标呈现在心中" class="headerlink" title="2. 想象：把目标呈现在心中"></a>2. 想象：把目标呈现在心中 </h3><p><em> 基于 斯蒂芬·科斯林(Stephen Kosslyn) 的研究</em></p>
<ul>
<li>“大脑可能分不清楚真实事物和想象事物的区别”</li>
<li>“模拟练习”<ul>
<li>引入各种器官，以便使想象更加地真实</li>
</ul>
</li>
</ul>
<h3 id="3- 认知疗法"><a href="#3- 认知疗法" class="headerlink" title="3. 认知疗法"></a>3. 认知疗法 </h3><p><em> 马丁·塞利格曼(Martin Seligman), 阿伦·贝克(Aaron Temkin Beck)</em></p>
<ul>
<li>“感情受思想的驱动”</li>
</ul>
<ul>
<li>Event –&gt; <strong>Evaluation(thought)</strong> –&gt; Emotion<ul>
<li>如果要想改变情绪，要从想法开始改变</li>
<li><strong>“重建理性和真实”</strong></li>
</ul>
</li>
</ul>
<h3 id="3Ms- 学说"><a href="#3Ms- 学说" class="headerlink" title="3Ms 学说"></a>3Ms 学说</h3><ul>
<li>3Ms：三个导致非理性思想的陷阱<ol>
<li>夸大理论：夸张了已发生的事实 &lt;–&gt; 归纳法与过度归纳<ul>
<li>归纳法：从已知的事情，来判断未知的类似的事情 –&gt; “这次干得不好” &lt;–&gt; “可能哪里出了问题”</li>
<li>过度归纳：“这次干得不好” &lt;–&gt; “我很蠢，这类事做不好” &lt;–&gt; “不成功便成仁”</li>
</ul>
</li>
<li>缩小理论：狭隘视野<ul>
<li>将注意力集中在某一个个体、个例上面</li>
</ul>
</li>
<li>伪造、捏造和情绪化推断<ul>
<li>推卸责任</li>
<li>“没人回来帮你把生活过得更美好，你必须承担起生活的责任”</li>
<li>“情绪不是现实，情绪只是对现实的推断”<ul>
<li>看清以及理性分析现实</li>
<li>作出正确的评估</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>实践<ul>
<li>我的结论是否贴合现实？</li>
<li>它是否理性？</li>
<li>我是否忽略了重要的（现实）因素？</li>
<li>我仍需要考虑什么重要因素？</li>
<li>“我在哪里扭曲了事实？”</li>
<li>“我在哪里扭曲了自己的评价？扭曲了自己的思想？从而导致了不必要的负面情绪”</li>
</ul>
</li>
</ul>
<h3 id="危机和机遇"><a href="# 危机和机遇" class="headerlink" title="危机和机遇"></a>危机和机遇</h3><ul>
<li>几乎所有杰出的人，都是经历过巨大的考验才成就辉煌</li>
<li><strong>挖掘苦难中的价值</strong></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软技能 </category>
            
            <category> 积极心理学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哈佛幸福课 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 幸福 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[8 感激]]></title>
      <url>/%E8%BD%AF%E6%8A%80%E8%83%BD/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/8.0-appreciate/</url>
      <content type="html"><![CDATA[<h2 id="是什么阻止我们乐观？"><a href="# 是什么阻止我们乐观？" class="headerlink" title="是什么阻止我们乐观？"></a>是什么阻止我们乐观？</h2><h3 id="舆论是乐观的杀手"><a href="# 舆论是乐观的杀手" class="headerlink" title="舆论是乐观的杀手"></a>舆论是乐观的杀手</h3><blockquote>
<p>媒体的职能之一就是突出那些本可以被纠正的错误，并发动大家一起去纠正，去改善。</p>
</blockquote>
<ul>
<li>媒体报道那些糟糕的、负面的信息，加上现在信息过载，加剧了负面信息的传播<ul>
<li>这是媒体的责任亦是媒体的“偏见”</li>
<li>过度聚焦负面信息只会加剧负面情绪</li>
<li>让人对现实产生负面联系<ul>
<li>过度报道某大公司非法交易 –&gt; 你想变得成功吗？那就得坑蒙拐骗</li>
<li>过度报道政客丑闻 –&gt; 政客都是骗子</li>
</ul>
</li>
</ul>
</li>
<li>“我们需要直面现实，直面负面消息的存在”</li>
</ul>
<h2 id="感激"><a href="# 感激" class="headerlink" title="感激"></a>感激</h2><ul>
<li>发自肺腑的感激能让积极情绪升值</li>
<li>感激帮助我们创造更积极的环境</li>
<li>感激能创造“积极情绪的螺旋上升”</li>
</ul>
<h3 id="适应性"><a href="# 适应性" class="headerlink" title="适应性"></a>适应性</h3><ul>
<li>对负面、异常情况的警觉是生存的本能</li>
<li>对异常情况产生适应性亦是生存本能</li>
<li>不要对生活“习以为常”<ul>
<li>不要认为那些平常的事物是“理所当然”的</li>
</ul>
</li>
</ul>
<h3 id="寻找值得感激的事物"><a href="# 寻找值得感激的事物" class="headerlink" title="寻找值得感激的事物"></a>寻找值得感激的事物</h3><ul>
<li>让自己更多地关注与生活中美的、积极的事物上</li>
<li>感激自己身上、周围值得感激的事物</li>
<li><strong>养成寻找幸福和感激 </strong> 的习惯<ul>
<li>一旦我们学会感激，我们就不会变得“理所当然”</li>
</ul>
</li>
</ul>
<h4 id="行动"><a href="# 行动" class="headerlink" title="行动"></a>行动</h4><ul>
<li>感受每一天<ul>
<li>“你通常干什么事情会不由自主地专心致志？”</li>
<li>认真地去做这些事情，不只是做这些事，同时你还在感激生活</li>
</ul>
</li>
</ul>
<h5 id="在每晚睡前写下五件让你感激的事物"><a href="# 在每晚睡前写下五件让你感激的事物" class="headerlink" title="在每晚睡前写下五件让你感激的事物"></a>在每晚睡前写下五件让你感激的事物</h5><ul>
<li>如何解决“习以为常”？当这件事已经失去新鲜感之后呢？当这件事已经变成例行公事之后呢？</li>
<li><p>解决方法：</p>
<ul>
<li>引入多种多样的人和事物</li>
<li>同样的事情多角度描写</li>
<li><em>艾伦·朗格</em> –&gt; “用心法则”：用心 –&gt; 创造新的区别<ul>
<li>用心观察，专注于此，发现新的区别</li>
<li>从专注中保持新鲜感</li>
</ul>
</li>
<li>词语形象化</li>
</ul>
<hr>
<blockquote>
<p>善用你的眼睛吧，犹如明天你将遭到失明的灾难；聆听乐曲的妙音，似乎你明天就会失聪。<br>抚摸每一件你想要抚摸的物品吧，犹如你明天的触觉将会衰减。嗅闻每一件你想要抚摸的物件 <br> 吧，犹如你明天即将失去嗅觉和味觉一样。 – 海伦·凯勒</p>
</blockquote>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软技能 </category>
            
            <category> 积极心理学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哈佛幸福课 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 幸福 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[9 积极情绪]]></title>
      <url>/%E8%BD%AF%E6%8A%80%E8%83%BD/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/9.0-positive-emotions/</url>
      <content type="html"><![CDATA[<h2 id="处理痛苦和积极情绪"><a href="# 处理痛苦和积极情绪" class="headerlink" title="处理痛苦和积极情绪"></a>处理痛苦和积极情绪 </h2><p><em> 基于 桑佳·吕波密尔斯基（Sonja Lyubomirsky）的研究</em></p>
<ul>
<li>痛苦情绪表达<ul>
<li>写、说更能化解痛苦情绪</li>
<li>在脑海中回忆会加剧痛苦情绪</li>
</ul>
</li>
<li>积极情绪<ul>
<li>说和写反而减弱积极情绪的持续化</li>
<li>回忆能让积极情绪变得更多</li>
</ul>
</li>
</ul>
<h3 id="分析和重现情绪"><a href="# 分析和重现情绪" class="headerlink" title="分析和重现情绪"></a>分析和重现情绪</h3><ul>
<li>分析经历有助于改善痛苦以及消极经历<ul>
<li>而分析美好的经历并不能增加很多积极情绪</li>
</ul>
</li>
<li>回忆积极情绪能让积极情绪持续更久<ul>
<li>单纯在脑海里思考只会让该消极情绪更甚<ul>
<li>PTSD 发生的区域调查</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>感激练习就是重现经历的练习</strong></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软技能 </category>
            
            <category> 积极心理学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哈佛幸福课 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 幸福 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[10 改变]]></title>
      <url>/%E8%BD%AF%E6%8A%80%E8%83%BD/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/10-change/</url>
      <content type="html"><![CDATA[<h2 id="改变如何发生？"><a href="# 改变如何发生？" class="headerlink" title="改变如何发生？"></a>改变如何发生？</h2><h3 id="改变的生物学原理"><a href="# 改变的生物学原理" class="headerlink" title="改变的生物学原理"></a>改变的生物学原理</h3><ul>
<li><strong><a href="https://zh.wikipedia.org/wiki/%E7%A5%9E%E7%BB%8F%E5%8F%AF%E5%A1%91%E6%80%A7" target="_blank" rel="external">神经可塑性</a></strong>（neural plasticity）</li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%A5%9E%E7%BB%8F%E5%8F%91%E7%94%9F" target="_blank" rel="external">神经发生</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%AA%81%E8%A7%A6%E5%8F%AF%E5%A1%91%E6%80%A7" target="_blank" rel="external">突触可塑性</a></li>
</ul>
<p>理解人脑内思考和记忆时，神经突触之类的建立和产生：</p>
<ul>
<li>挖掘新的神经链接</li>
<li>拓宽已有的神经链接</li>
</ul>
<h2 id="是否要进行改变？"><a href="# 是否要进行改变？" class="headerlink" title="是否要进行改变？"></a>是否要进行改变？</h2><ul>
<li>性格是相对的<ul>
<li>苛刻和严谨</li>
<li>轻信和信赖</li>
</ul>
</li>
<li>潜意识有可能对某个性格的伴生点有依赖性<ul>
<li>不愿意放弃严谨的态度，但是容易造成对事物过于苛刻的情况</li>
<li>比如焦虑和责任感相伴生</li>
</ul>
</li>
<li>潜意识的联系和社会要求以及自我实现有关<ul>
<li>不愿意对别人说“不”，可能是希望获得一个“善解人意、有同理心”的社会评价</li>
<li>无法摆脱放松和获得幸福的冲突，可能是潜意识倾向于“幸福需要经过苦难、人不能不劳而获”的思维习惯</li>
</ul>
</li>
</ul>
<h4 id="改善想法"><a href="# 改善想法" class="headerlink" title="改善想法"></a>改善想法</h4><ul>
<li>理解思维的误区</li>
<li>要清除“两者”的区别</li>
<li>“<strong>自己想要什么</strong>”？</li>
</ul>
<p>通过不断的 <strong> 自我询问 </strong> 来获得对已有习惯性思维的新的理解，摆脱麻木，获得新的体验。</p>
<h2 id="什么能被改变？"><a href="# 什么能被改变？" class="headerlink" title="什么能被改变？"></a>什么能被改变？</h2><p><em>基于 艾德·狄纳(Ed Denier) 和 桑佳·吕波密斯基(Sonja Lyubomirsky) 的研究</em> </p>
<p><strong>我们要改变什么？我们能改变什么？不能改变什么？</strong> </p>
<ul>
<li>个体幸福感分析<ul>
<li>基因设定范围（×）<ul>
<li>“ 50% ”</li>
<li>对于与生俱来的东西我们要接受并充分利用好他</li>
<li>幸福水平只有一部分取决于基因</li>
</ul>
</li>
<li>外部环境（×）<ul>
<li>“ 10% ”</li>
<li>极端社会环境比如社会制度</li>
</ul>
</li>
<li>受意识行为支配的那部分（√）<ul>
<li>行为处事方式、思想、世界观以及我们的生活重心</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="改变的两种方式"><a href="# 改变的两种方式" class="headerlink" title="改变的两种方式"></a>改变的两种方式 </h2><p><strong> 在两种方式下，均会和之前 <a href="https://wiki.rosuh.me/wiki/7-adversity-or-chance/"> 讲到的 A B C 模式相对应</a></strong>：</p>
<ul>
<li>A ：情感，情绪</li>
<li>B ：行动</li>
<li>C ：思想</li>
</ul>
<h3 id="逐渐改变"><a href="# 逐渐改变" class="headerlink" title="逐渐改变"></a>逐渐改变</h3><ul>
<li>A：冥想（<em>基于 乔恩·卡巴泽（Jon Kabat-Zin）的研究</em> ）<ul>
<li>锻炼冥想能力可以引领我们达到身心舒展、内心平和以及自我审视的更高境界 </li>
</ul>
</li>
<li>B：“肢体反馈假说”<ul>
<li>心理态度和行为的关系<ul>
<li>大脑的一致性：其中一个改变，必须保持同步；要么回落已提升的态度，要么提高现有的行为</li>
<li>习惯是习惯性行为，行为是情绪的一个一致性体现</li>
<li>如果不做出行为上的改变，任何心理、知识提升都将被拉回原来的水平<ul>
<li>学习新知识亦是同理</li>
</ul>
</li>
<li>细分而言的坐姿、表情、走路姿态等等都会反过来影响情绪；亦会想周围环境传递消息</li>
</ul>
</li>
</ul>
</li>
<li>C：认知重构<ul>
<li>对事物的解释角度决定了接受的信息<ul>
<li>积极接受 &lt;–&gt; 将苦难看做挑战<ul>
<li><strong>积极 </strong> 接受那些坏的消息、情绪</li>
</ul>
</li>
<li>适当表现出来</li>
<li>对恢复如初满怀希望</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="激进改变"><a href="# 激进改变" class="headerlink" title="激进改变"></a>激进改变</h3><ul>
<li>A：PTSD 与 “高峰体验理论”<ul>
<li>PTSD 是激进改变的绝佳论证，同时伴随的“创伤后成长”理论亦是一种益处</li>
<li>“高峰体验假说”：人生最美好的时刻，是瞬间强烈的幸福感，甚至是对欣喜若狂、如痴如醉、欢乐至极的浓缩。这样的体验来自于高深的美学体验，比如创作的喜悦、美好的爱情、完美的性爱、亲子间的关怀、自然分娩以及其他众多体验</li>
<li>保持“高峰体验”的后续情绪</li>
</ul>
</li>
<li>B<ul>
<li>直面风险和自己不情愿做的事情 &lt;–&gt; 跳出舒适区、进入学习区</li>
</ul>
</li>
</ul>
<p><img src="http://oq3jfi5lh.bkt.clouddn.com/blog/20170816/113008992.png?imageslim" alt="..."></p>
<ul>
<li>C：顿悟体验（eureka experience）<ul>
<li>前期准备阶段：沉浸的思想体验</li>
<li>中期休息阶段：间断性思考的重要性</li>
<li>活力爆发：顿悟体验</li>
<li>评估阶段：实验、实践然后评估理论正确性</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软技能 </category>
            
            <category> 积极心理学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哈佛幸福课 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 视频 </tag>
            
            <tag> 幸福 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[积极心理学资料索引与声明]]></title>
      <url>/%E8%BD%AF%E6%8A%80%E8%83%BD/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6%E8%B5%84%E6%96%99%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%A3%B0%E6%98%8E/</url>
      <content type="html"><![CDATA[<p>《积极心理学》 系列 <strong> 笔记 </strong>，是笔者个人的学习记录摘抄。<br> 其中主要的参考资料是（文章中将不再列出，除非特殊来源）：<br><a href="http://open.163.com/special/opencourse/positivepsychology.html" target="_blank" rel="external">哈佛大学公开课：幸福课</a></p>
<ul>
<li>多数结论、文字皆为摘抄自视频中，少数为笔者自己的总结。</li>
<li>本系列的文章内容架构为笔者自行梳理。</li>
<li>多数图片为笔者自行制作，少数来自网上或公开的资料</li>
</ul>
<p>如果本系列文章有侵犯到您权利的地方，请立刻联系笔者！</p>
]]></content>
      
        <categories>
            
            <category> 软技能 </category>
            
            <category> 积极心理学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哈佛幸福课 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[华为 A199 救砖札记]]></title>
      <url>/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/save-blocked-in-A199/</url>
      <content type="html"><![CDATA[<h2 id="1- 前言"><a href="#1- 前言" class="headerlink" title="1. 前言"></a>1. 前言 </h2><p> 这货之前一直被我丢在柜子里。晚上想要注册多一个微信号，需要多一台设备来登陆。毕竟双开有被封号的风险。</p>
<p>之前已经刷入了第三方的 REC，所以本以为挺简单。想着先刷回官方版本，然后自己精简的。</p>
<p>于是安装官方的指引：</p>
<ol>
<li>官方的包解压出来，把 <code>dload</code> 放到了外置 SD 卡</li>
<li>设置–&gt; 关闭快速启动</li>
<li>设置–&gt; 关于手机–&gt; 系统更新–&gt; 本地升级</li>
<li>重启</li>
</ol>
<p><strong>然后就崩了</strong>…</p>
<p>第三方的 REC 无法识别，然后一直卡在 TWRP 的界面，重启或者试图进入 REC 都会一直卡在 TWEP 启动界面。</p>
<p>然后在官方论坛找了一下，没什么有用的帖子…刷机氛围真是不行…</p>
<p>直到看到某个官方教程帖子里说，华为的 fastboot 界面其实就是开机界面（麦芒 A199 的就是那个麦芽）。使用 <strong> 音量键减 + 开机键 </strong> 进入。</p>
<p>能进入 fastboot 说明还是有救的。</p>
<h2 id="2- 环境准备"><a href="#2- 环境准备" class="headerlink" title="2. 环境准备"></a>2. 环境准备 </h2><h3 id="2-1- 安装驱动"><a href="#2-1- 安装驱动" class="headerlink" title="2.1 安装驱动"></a>2.1 安装驱动</h3><p> 我使用的是 Win10，需要安装华为的驱动之后才能识别设备，不然 fastboot 是无法查找到设备的。</p>
<p><a href="http://consumer.huawei.com/cn/support/search/index.htm?keywords=%E9%BA%A6%E8%8A%92A199" target="_blank" rel="external">关键词搜索：麦芒 A199</a></p>
<p>华为官方的搜索界面都找不到这机子了…滑到列表最下面，看到 <code>HUAWEI Stick UTPS-V200R003B015D11SP01C983(for win10)</code> 这个选项：</p>
<p><img src="https://img.rosuh.me/wiki/58ca9d2bd48d2.png" alt="HUAWEI Stick UTPS-V200R003B015D11SP01C983( for win10)"></p>
<p>然后下载下来。如果官方撤了这个文件，可以到我分享的度盘下载：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链接: http:<span class="comment">//pan.baidu.com/s/1dFadWkT 密码: bdyd</span></span><br></pre></td></tr></table></figure>
<p>下载之后解压再解压，里面是一个 <code>iso</code> 镜像文件，可以选择装载到你的虚拟驱动器，或直接解压出来都没问题。</p>
<p>打开 <code>AutoRun.exe</code> 安装，就行了。</p>
<p>照道理现在应该已经装好了。我就是这么装的，并且之前我的系统也没有装过华为的其他驱动，所以我判断这样应该就可以。</p>
<h3 id="2-2- 刷入 -REC"><a href="#2-2- 刷入 -REC" class="headerlink" title="2.2 刷入 REC"></a>2.2 刷入 REC</h3><ol>
<li>获取 ADB 套件</li>
</ol>
<p>这一步需要用到 <code>adb</code> 套件。</p>
<p>点击下面的链接从 Google 官方下载：</p>
<p><a href="https://dl.google.com/android/repository/platform-tools-latest-windows.zip" target="_blank" rel="external">https://dl.google.com/android/repository/platform-tools-latest-windows.zip</a></p>
<p>如果因为某些 <strong> 不可描述 </strong> 的原因导致你无法下载，可以通过我分享的度盘链接下载：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链接: http:<span class="comment">//pan.baidu.com/s/1miQCxnU 密码: kyum</span></span><br></pre></td></tr></table></figure>
<p><em>建议从官方下载，保证取得最新版的套件</em>。</p>
<p>下载之后解压出来，得到 <code>adb</code>套件。</p>
<ol>
<li>获取官方的 REC</li>
</ol>
<p>麦芒的官方 REC 我在论坛没找到。所以需要从官方的 ROM 中提取出来。</p>
<p>下面是提取的步骤，如果你不想自己提取，可以直接用我提取出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链接: http:<span class="comment">//pan.baidu.com/s/1eRO689O 密码: q4f9</span></span><br></pre></td></tr></table></figure>
<p><a href="http://www.emui.com/plugin.php?id=hwdownload&amp;mod=detail&amp;mid=1" target="_blank" rel="external">官方 ROM 下载</a></p>
<p>如果官方撤掉了，从我的盘下载：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链接: http:<span class="comment">//pan.baidu.com/s/1c21kqDq 密码: pi7u</span></span><br></pre></td></tr></table></figure>
<p>提取 REC 需要用到一个提取软件，直接点下面下载：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链接: http:<span class="comment">//pan.baidu.com/s/1boDhujH 密码: 5kun</span></span><br></pre></td></tr></table></figure>
<p>下载完解压出来，双击运行<code>HuaweiUpdateExtractor.exe</code>。</p>
<p>选择 <code>Update File</code> 右边的按钮选择官方 ROM</p>
<p><img src="https://img.rosuh.me/wiki/58ca9fa275ed9.png" alt="HuaweiUpdateExtractor"></p>
<p>选择 ROM 之后，右键单击 <code>RECOVERY</code> 解压出来：</p>
<p><img src="https://img.rosuh.me/wiki/58caa084186d0.png" alt="解压 REC"></p>
<p>然后把解压出来的 <code>RECOVERY</code> 放到第一步中 ADB 套件的文件夹中。</p>
<ol>
<li>刷入 REC</li>
</ol>
<p>进入 ADB 套件文件夹，可以看到诸如 <code>adb</code>, <code>fastboot</code> 等工具。</p>
<p>按住键盘的 <code>Shift</code> 键，同时鼠标右键单击该文件夹的空白处，选择“在此处打开命令行窗口”：</p>
<p><img src="https://img.rosuh.me/wiki/58caa1a512317.png" alt="open ps"></p>
<p>我这里是 <code>Powershell</code> 窗口，大部分时候显示为 <code>cmd</code> 窗口。</p>
<p>按住手机 <strong> 音量键减 + 开机键 </strong> 进入 <code>fastboot</code> 模式，显示为开机的那个麦芽 logo。</p>
<p>进入命令行界面，输入以下命令检查设备是否链接：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot.exe devices</span><br></pre></td></tr></table></figure>
<p>如果有输入提示（一般是含有一串数字 + 英文字母），则意味着设备已经被识别了。如果没什么输出、提示，则意味着没有被识别。那么你要自行寻找其他驱动。</p>
<p>接着输入以下命令，进行刷入 REC</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot.exe flash recovery RECOVERY.img</span><br></pre></td></tr></table></figure>
<p>输入回车之后应该就开始刷入了。命令行窗口会有提示：</p>
<p><img src="https://img.rosuh.me/wiki/58caa385361f6.png" alt="Flash REC"></p>
<p>由于我之前是升级过程卡住了，刷入 REC 之后自动开始了流程，这点还是很赞的：</p>
<p><img src="https://img.rosuh.me/wiki/58caa3eaaed61.jpg" alt="show time"></p>
<p>接着就可以进行愉快地玩耍啦~</p>
<hr>
<p><em>Best Wish.</em></p>
<p><em>by rosu</em></p>
<p><em>2017-3-16</em></p>
]]></content>
      
        <categories>
            
            <category> 玩机技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> huawei </tag>
            
            <tag> A199 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu 安装软件合集]]></title>
      <url>/Linux-VPS/softwares/</url>
      <content type="html"><![CDATA[<h2 id="记录 -Ubuntu- 平台下安装的部分软件。"><a href="# 记录 -Ubuntu- 平台下安装的部分软件。" class="headerlink" title="记录 Ubuntu 平台下安装的部分软件。"></a> 记录 Ubuntu 平台下安装的部分软件。</h2><p><a href="https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/#%E7%9B%AE%E5%BD%95" target="_blank" rel="external">awesome-linux-software</a></p>
<h1 id="Node-js-amp- 版本管理"><a href="#Node-js-amp- 版本管理" class="headerlink" title="Node.js &amp; 版本管理"></a>Node.js &amp; 版本管理 </h1><ul>
<li> 推荐的安装方式是通过 nvm</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> verify installtion</span><br><span class="line">command -v nvm</span><br><span class="line"><span class="meta">#</span> print</span><br><span class="line">nvm</span><br><span class="line"><span class="meta">#</span> install nodejs</span><br><span class="line">nvm install node</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> special in o-my-zsh</span><br><span class="line"><span class="meta">#</span> install as plugin</span><br><span class="line">git clone https://github.com/lukechilds/zsh-nvm~/.oh-my-zsh/custom/plugins/zsh-nvm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> edit ~/.zshrc</span><br><span class="line">plugins+=(zsh-nvm)</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a></p>
<h1 id="S-S-Libev"><a href="#S-S-Libev" class="headerlink" title="S-S-Libev"></a>S-S-Libev</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span> 提示 </span><br><span class="line">add-apt-repository: command not found</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装工具包 </span><br><span class="line">apt-get install software-properties-common</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装 libev</span><br><span class="line">sudo add-apt-repository ppa:max-c-lv/shadowsocks-libev</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install shadowsocks-libev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动时提示 </span><br><span class="line">This system doesn't provide enough entropy to quicklygenerate high-quality random numbers</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装 rng-tools 工具 </span><br><span class="line"></span><br><span class="line">apt install rng-tools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 4 in 1</span><br><span class="line">wget --no-check-certificate -O shadowsocks-all.shhttps://raw.githubusercontentcom/teddysun/shadowsocks_install/master/shadowsocks-allsh</span><br><span class="line">chmod +x shadowsocks-all.sh</span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure>
<h1 id="KeePass2"><a href="#KeePass2" class="headerlink" title="KeePass2"></a>KeePass2</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apt install keepass2</span><br></pre></td></tr></table></figure>
<h1 id="Uget"><a href="#Uget" class="headerlink" title="Uget"></a>Uget</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo add-apt-repository ppa:plushuang-tw/uget-stable</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install uget</span><br></pre></td></tr></table></figure>
<h1 id="Oracle-Java"><a href="#Oracle-Java" class="headerlink" title="Oracle Java"></a>Oracle Java</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span> 清除已经安装的 OpenJDK</span><br><span class="line">sudo apt-get purge openjdk-\*</span><br><span class="line"><span class="meta">#</span> 安装 Oracle JDK</span><br><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br></pre></td></tr></table></figure>
<p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-ubuntu-16-04" target="_blank" rel="external">how to install java with apt get on ubuntu 16.04</a></p>
<h1 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br><span class="line">sudo dpkg -i google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure>
<h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> optional, but recommended</span><br><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line"><span class="meta">#</span> add Typora's repository</span><br><span class="line">sudo add-apt-repository'deb https://typora.io ./linux/'</span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="meta">#</span> install typora</span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure>
<h1 id="you-get"><a href="#you-get" class="headerlink" title="you-get"></a>you-get</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> install ffmpeg</span><br><span class="line">sudo add-apt-repository ppa:mc3man/trusty-media</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install ffmpeg</span><br><span class="line"><span class="meta">#</span> install you-get</span><br><span class="line">pip3 install you-get</span><br><span class="line"><span class="meta">#</span>usage</span><br><span class="line">you-get url</span><br></pre></td></tr></table></figure>
<h1 id="Guake- 终端"><a href="#Guake- 终端" class="headerlink" title="Guake 终端"></a>Guake 终端 </h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/unstable</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<p> 到 Github 页面下载最新版本并解压，之后执行 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./dev.sh --install</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Guake/guake" target="_blank" rel="external">Guake</a></p>
<h1 id="BBR"><a href="#BBR" class="headerlink" title="BBR"></a>BBR</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh </span><br><span class="line">chmod +x bbr.sh </span><br><span class="line">./bbr.sh</span><br></pre></td></tr></table></figure>
<h1 id="Coursera-dl"><a href="#Coursera-dl" class="headerlink" title="Coursera-dl"></a>Coursera-dl</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install coursera-dl</span><br><span class="line"><span class="meta">#</span> sometime you need to restart your shell</span><br><span class="line">exec $SHELL</span><br></pre></td></tr></table></figure>
<h1 id="Firefox-beta"><a href="#Firefox-beta" class="headerlink" title="Firefox beta"></a>Firefox beta</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:mozillateam/firefox-next</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-fast install firefox</span><br></pre></td></tr></table></figure>
<h1 id="Telegram"><a href="#Telegram" class="headerlink" title="Telegram"></a>Telegram</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:atareao/telegram</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-fast install telegram</span><br></pre></td></tr></table></figure>
<h1 id="Wechat- 微信"><a href="#Wechat- 微信" class="headerlink" title="Wechat 微信"></a>Wechat 微信 </h1><p><a href="https://github.com/geeeeeeeeek/electronic-wechat" target="_blank" rel="external">electronic-wechat</a></p>
<h1 id="网易云"><a href="# 网易云" class="headerlink" title="网易云"></a> 网易云 </h1><ul>
<li><p> 魔改版 </p>
<ul>
<li><a href="https://github.com/trazyn/ieaseMusic" target="_blank" rel="external">ieaseMusic</a></li>
</ul>
</li>
</ul>
<h1 id="电源管理"><a href="# 电源管理" class="headerlink" title="电源管理"></a> 电源管理 </h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-fast install tlp tlp-rdw</span><br><span class="line">sudo tlp start</span><br></pre></td></tr></table></figure>
<h1 id="系统监视器"><a href="# 系统监视器" class="headerlink" title="系统监视器"></a> 系统监视器 </h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-psutil curl git gir1.2-appindicator3-0.1</span><br><span class="line">git clone https://github.com/fossfreedom/indicator-sysmonitor.git</span><br><span class="line">cd indicator-sysmonitor</span><br><span class="line">sudo make install</span><br><span class="line">nohup indicator-sysmonitor &amp;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/fossfreedom/indicator-sysmonitor" target="_blank" rel="external">indicator-sysmonitor</a></p>
]]></content>
      
        <categories>
            
            <category> Linux &amp; VPS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VPS </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
